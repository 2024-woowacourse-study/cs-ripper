### 운영체제란 무엇인가?

운영체제란 컴퓨터의 하드웨어를 관리하기 위한 소프트웨어 시스템을 말합니다.

보통 메모리 관리, 프로세스 관리, 자원 관리 등을 담당합니다. 


### 커널이란 무엇인가?

운영체제의 핵심 부분으로 직접 하드웨어에 대한 관리를 처리하는 핵심 소프트웨어

### 커널모드 vs 유저모드 (CPU의 실행모드)

커널에서 중요한 자원을 관리한다. 시스템에 영향을 미치는 중요한 연산과 그렇지 않은 연산을 분리해서 실행하는데, 이때 중요한 영향을 미치는 연산을 커널모드에서 실행한다.

- 커널 모드는 운영체제 코드나 디바이스 드라이버 같은 코드가 실행, 모든 자원에 접근이 가능
- 유저 모드는 유저 애플리케이션 코드가 실행되는 모드로, 유저가 접근할 수 있는 영역을 제한하고 자원에는 침범하지 못하도록 하는 것
  - 사용자 모드에서는 프로세스가 할당 받은 메모리에만 접근할 수 있음

> 유저모드 → 모드 비트 0
> 
> 사용자모드 → 모드 비트 1

### 시스템 콜

리소스가 필요한 작업 등 커널이 제공하는 기능을 사용하기 위해 커널이 제공하는 인터페이스로, 자원을 보호하는 것이 목적

실제 응용 프로그램이 실제 자원에 직접 접근하게 되면 자원에 영향이 갈 수 있음

시스템 콜을 기반으로 유저와 커널이 분리되는데, **시스템 콜이 호출될 경우 유저 모드에서 커널 모드의 영역으로 일시 전환**된다.
- 시스템 콜의 종류에는 프로세서 제어, 파일 조작, 장치 관리, 시스템 정보 및 자원 관리, 통신 등

### 시스템 콜 호출 시 어떻게 처리?

시스템 콜은 소프트웨어 인터럽트(트랩)다

1. 콜 요청
    - 시스템 콜 인자들(인덱스)를 CPU 레지스터에 저장
    - 인터럽트 발생
2. 사용자 모드에서 커널 모드로 전환
    - IDT(Interrupt Descriptor Table)를 참조하여 system_call()을 호출
    - 앞에서 저장한 인덱스를 system_call() 함수 내에 전달
3. 시스템 콜 처리
    - sys_call_table을 참조해 해당 인덱스에 맞는 기능(sys_write)을 호출
4. 결과 반환 및 복귀
    - 수행이 모두 끝나면 사용자 모드로 전환

### 인터럽트

**입출력 관리자가 CPU에게 보내는 완료 신호**

CPU가 작업을 실행할 때 모든 입출력 작업까지 처리하게 되면 비효율적이다.

따라서 이에 소요되는 시간을 줄이기 위해 입출력과 CPU을 독립적으로 운영하게 된다.

### 인터럽트 VS 트랩

인터럽트는 하드웨어 인터럽트, 소프트웨어 인터럽트로 나뉘며 주로 하드웨어 인터럽트를 인터럽트라고 명명

- 인터럽트: 외부에서 발생(하드웨어 인터럽트)
  - 입출력 장치, 하드웨어 고장, 전원 이상 등에 의해 발생
- 트랩: 내부에서 발생(소프트웨어 인터럽트)
  - 오버플로우, 불법적인 파일 접근 시도 등 프로그램 실행 중 특정 조건 발생 시 발생

### DMA(Direct Memory Access)

입출력 관련 작업을 할 때, CPU가 직접 입출력까지 처리하게 되면 효율적이지 못함

CPU가 입출력 매니저에게 입출력 관련 관련 권한을 위임하여 효율성을 높힌다.

원래는 CPU만 메모리에 접근이 가능한데, DMA를 사용하여 CPU를 거치지 않도록 함

즉, 직접 메모리와 입출력 장치 간에 직접 데이터를 전송할 수 있는 기능

### 프로세스란?

실행 중인 프로그램으로, 각각 독립된 메모리 공간을 가지는 실행 단위

PCB를 통해 관리되는 작업 단위

### 스레드

프로세스 내에서 실제로 작업을 실행하는 실행의 단위

스레드 간에는 코드, 데이터, 힙 영역을 공유하며, 스택만 독립적으로 사용할 수 있다.

### 멀티스레딩

하나의 프로세스 내에서 여러 스레드가 동시에 작업을 수행하는 것

공유자원에 대한 문제(교착 상태, 경쟁 조건)가 발생할 가능성이 있다.

멀티 프로세스에 비해 컨텍스트 스위칭 비용이 적다는 장점이 있다.

### 멀티 프로세싱

여러 개의 프로세스가 동시에 실행되는 것

### 멀티 스레드, 멀티 태스킹, 멀티 프로세싱

멀티 스레드: 하나의 프로세스 안에서 여러 개의 스레드가 동시에 작업을 수행

멀티 태스킹: 여러 작업을 동시에 수행하는 것처럼 보이도록 하는 시스템

멀티 프로세싱: 여러 개의 프로세서(CPU)가 여러 개의 프로세스를 동시에 처리

### 컨텍스트 스위칭

현재 실행 중인 프로세스/스레드의 상태를 저장하고 다음 프로세스/스레드를 실행하는 과정

- 실행 중인 프로세스/스레드의 상태를 저장하고
- 다음 실행할 프로세스/스레드의 상태를 복원하는 작업
- CPU가 다른 프로세스로 전환하는 과정

Process Context Switching 과정 = **커널 모드 전환** + **CPU register 상태 교체** + 가상 메모리 주소 처리(**MMU 수정** + **TLB 캐시 비우기**)

Thread Context Switching 과정 = **커널 모드 전환** + **CPU register 상태 교체**

### 리눅스 스케줄러 종류

장기: 어떤 프로세스를 Ready Queue**에 넣을 것인가**(Job Scheduler), 메모리에 올라갈 프로세스 선택

중기: 활성화된 프로세스 관리, 메모리 여유 공간 확보를 위한 스와핑

단기: CPU에서 실행할 다음 프로세스 선택, Ready Queue에서 프로세스 선택

### 프로세스의 상태

1. 생성 → PCB를 할당받은 상태
2. 준비 → 실행 단계 전, CPU를 할당 받기 위해 대기하는 상태
3. 실행 → CPU가 처리하고 있는 상태
4. 대기 → 입출력 관련 작업의 처리를 위해 실행 상태에서 대기 중인 상태
5. 종료 → 프로세스가 종료되는 상태

### 스케줄링 기법
1. FCFS (First Come First Served): 가장 단순한 스케줄링 방식, 먼저 도착한 프로세스를 먼저 처리하는 방식
2. SJF (Shortest Job First): 실행시간이 가장 짧은 프로세스 우선 실행
3. 우선순위 스케줄링
4. Round Robin: 시간 할당량(quantum)을 기준으로 프로세스 교체

### 선점형, 비선점형 스케줄링
선점형
- 운영체제가 강제로 프로세스 실행을 중단하고 다른 프로세스를 실행
- 우선순위가 높은 프로세스가 CPU를 차지
- 응답성이 좋음
- 문맥 교환 오버헤드가 큼

비선점형
- 프로세스가 자발적으로 CPU를 반납할 때까지 실행
- 문맥 교환 오버헤드가 적음
- 응답시간이 늦을 수 있음
- 우선순위가 높은 프로세스도 대기해야 함

### 동기와 비동기

**Synchronous** (동기) : 작업을 동시에 수행하거나, 동시에 끝나거나, 끝나는 동시에 시작함을 의미

**Asynchronous** (비동기) : 시작, 종료가 일치하지 않으며, 끝나는 동시에 시작을 하지 않음을 의미

### 프로세스(스레드) 동기화

자원의 일관성 보장을 위한 과정

- **1. 상호 배제 (mutual exclusion)**
    - 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 들어올 수 없다.
- **2. 진행 (progress)**
    - 임계 구역에 어떤 프로세스도 진입하지 않았다면 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
- **3. 유한 대기 (bounded waiting)**
    - 한 프로세스가 임계 구역에 진입하고 싶다면 언젠가는 임계 구역에 들어올 수 있어야 한다.
      
### **데드락**

여러개의 프로세스가 공유자원을 놓고 무한 대기하는 현상, 아래 4가지의 요소가 모두 발생해야 발생할 가능성이 있다.
1. 상호배제(Mutual Exclusion)
- 자원은 한 번에 한 프로세스만 사용 가능
2. 점유와 대기(Hold and Wait)
- 자원을 가진 상태에서 다른 자원 요청 가능
3. 비선점(No Preemption)
- 다른 프로세스의 자원을 강제로 빼앗을 수 없음
4. 순환 대기(Circular Wait)
- 프로세스간 자원 요청이 순환 형태를 이룸

데드락 처리 방법

1. 예방(Prevention)
- 4가지 발생 조건 중 하나를 제거
2. 회피(Avoidance)
- 자원 할당 자체를 피하는 방법
- unsafe, safe 중 safe 상태일 때만 자원을 할당하는 것
3. 탐지 및 복구(Detection & Recovery)
- 주기적으로 데드락 검사
- 발견 시 프로세스 강제 종료 등으로 복구
4. 무시(Ignorance)
- 데드락 발생을 무시

### 메모리 주소 바인딩

CPU가 프로세스의 작업을 수행하기 위해서 프로세스의 논리적 주소를 참조하게 된다. 
논리적 주소만으로는 실제 메모리의 주소를 알 수 없기 때문에 논리 주소를 물리적 메모리로 연결시키는 작업

### Swapping

프로세스 RAM이 부족할 때, 사용하지 않는 메모리를 하드디스크로 옮기는 작업

디스크 공간을 가상 메모리로 활용하는 프로세스

### 메모리 단편화

메모리 공간을 효율적으로 사용하지 못하고 작은 메모리 공간들로 나누어지는 현상 

외부 단편화(External Fragmentation)
- 가변 분할 방식에서 발생하며, 프로세스들이 메모리를 할당받았다가 반환하는 과정에서 남은 메모리들에 발생

내부 단편화(Internal Fragmentation)
- 주로 고정 분할 방식에서 발생하며, 메모리가 고정된 크기의 블록으로 할당될 때 프로세스가 필요한 양보다 더 큰 메모리를 할당받음

### 메모리 할당 방식

|구분|가상 메모리|물리 메모리|
|----|----|----|
|메모리 분할 방식|세그먼테이션|가변 분할 방식|
|메모리 분할 방식|페이징|고정 분할 방식|


### 페이징

페이징(Paging)은 메모리 관리 기법 중 하나로, 물리 메모리와 가상 메모리를 일정한 크기의 블록(페이지)으로 나누어 관리하는 방식입니다.

- 페이지(Page): 가상 메모리를 일정한 크기로 나눈 블록
- 프레임(Frame): 물리 메모리를 페이지와 동일한 크기로 나눈 블록
- 페이지 테이블: 페이지와 프레임의 매핑 정보를 담는 테이블
    - 모든 프로세스는 페이지 테이블을 가진다.
- TLB(페이지 테이블 캐시 메모리)를 통해 접근 시간을 줄인다.

### 세그멘테이션

메모리 관리 기법 중 하나로, 각 프로세스의 메모리를 연속되게 할당하는 방법

자신의 크기와 동일한 파티 적재한다.

세그먼테이션 테이블을 사용하여 매핑: limit(세그멘트의 크기), address(물리 메모리 시작 주소)

### 세그멘테이션-페이징 혼합

세그멘테이션과 페이징의 장점을 결합한 메모리 관리 방식

세그먼트 단위로 일단 분할하고, 분할한 세그먼트를 다시 페이지 단위로 

페이지 테이블과 가상 메모리 사이에 세그먼트 테이블을 추가하여 관리


### 가상 메모리

가상 메모리(Virtual Memory)는 물리 메모리의 크기에 상관없이 프로세스에 큰 메모리 공간을 제공하는 기술

가상 메모리 덕분에 프로세스는 실제 메모리의 크기를 몰라도 된다.

- 장점
  - 실제 메모리 크기보다 큰 프로세스도 실행 가능
  - 여러 프로세스에서 동일한 페이지는 하나의 페이지만 적재하여 효율적으로 사용 가능

### **Page Fault(페이지 부재)**

페이지 테이블에는 **유효 비트**라는 페이지가 메모리에 현재 적재되어 있는지 여부를 알려주는 게 있음

이 유효 비트가 0일 때 발생하는 인터럽트

- 발생 시 처리 과정
    - CPU 기존 작업 내역을 백업
    - 페이지 폴트 처리 루틴 실행
    - 원하는 페이지를 메모리로 가져오고 유효 비트를 1로 변경
    - 페이지 폴트를 처리 완료
 
### 페이지 교체
    
당장 실행해야할 페이지 적재를 위해 필요하지 않은 페이지들을 보조기억장치로 내보내는 데 사용되는 알고리즘
    
- FIFO 페이지 교체 알고리즘: 가장 먼저 올라온 페이지부터 내쫓는 방식
- 최적 페이지 교체 알고리즘: CPU에 의해 참조되는 횟수를 고려하는 방식, 사용 빈도가 가장 “낮을” 페이지를 교체하는 알고리즘
- LRU 페이지 교체: 가장 오래 사용되지 않은 페이지를 교체

페이지 폴트가 적을수록 좋은 알고리즘 → 보조기억장치에 많이 접근하면 성능이 저하되기 때문

### Thrashing

시스템이 실제 작업보다 페이지 교체(페이징)에 더 많은 시간을 소비하는 현상

- 프로세스에 할당된 프레임이 너무 적을 때
- 다중 프로그래밍 정도가 너무 높을 때
- 프로세스의 작업 집합(Working Set)을 수용하기에 메모리가 부족할 때

어떻게 해결?

- Page Fault Frequency
  - 한 프로세스 당 상,하한을 조절하여 페이지 수를 늘리거나 낮추거나 상,하한보다
- Working Set
  - 활성화된 페이지의 집합을 묶고 그 집합의 크기가 실제 메모리의 프레임 합보다 작을 경우 쓰레딩이 발생한다고 간주
  - working set의 합을 줄이기 위해 일부 프로세스를 죽인다.

### 파일 시스템

데이터를 파일 형태로 저장하고 관리하는 방법

파일 구성, 관리, 접근 권한 관리, 암호화 등이 파일 시스템의 기능

파일 관리자가 파일 테이블을 생성하여 파일을 관리

### 디스크 블록 할당 방법
    
1. 연속
    
디스크의 연속된 기억공간에 할당하는 방법
- 생성된 파일 크기만큼의 공간이 있어야 함
- 파일 수정 시에 연속된
- 외부 단편화 문제 발생 가능

2. 연결    
- 각 블록이 다음 블록의 포인터를 저장
- 랜덤 엑세스가 불가능하다
  - FAT를 사용하여 해결 가능

3. 인덱스 할당
- 색인 할당 역시 연결 할당과 같이 데이터를 랜덤한 블록 번호에 할당하지만 할당된 블록 번호(포인터)를 하나의 블록에 따로 저장


### 캐시의 지역성
    
캐시의 적중율을 극대화 하기 위해 사용하는 특성으로
    
데이터를 균일하게 Access 하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성
    
- 시간적 지역성(Temporal Locality)
    - 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성
- 공간적 지역성(Spatial Locality)
- 서로 인접하여 저장되어 있는 데이터들이 연속적으로 액세스 될 가능성이 높아지는 특성

### 캐싱 라인
    
캐시에 데이터가 저장될 때, 묶이는 기본적인 단위
    
자주 사용되는 데이터들을 묶어서 저장하여 더 빠르게 저장할 수 있도록 하는 것
    
- 빈번하게 사용되는 데이터의 주소들이 일정한 태그들로 묶여있으면 아무래도 찾기가 쉬워질 것이다.
- 캐시 메모리는 메인 메모리에 비해 크기가 매우 작기 때문에, 메인 메모리와 1:1 매칭이 불가능 → 어디에 저장되어있는지 찾는데 오래 걸리면 비효율적

방식
- DM(direct memory)
  - memory에 들어갈 부분과 캐시에 들어갈 부분을 동일한 크기로 나누고
- Associative Mapping
  - 순서 상관없이 어디에든 저장
  - 즉, 캐시 1에는 메모리를 110번을, 캐시2에는 메모리 1120을 위치시키는것
  - 하지만 특정메모리 위치의 값을 자주 불러다 사용한다 기존에 있던 데이터를 쫓아내기 때문에
- Set Associative Mapping
  - 순서를 일치시키면서 일정 그룹을 두지만, 그 그룹내에서는 편하게 저장하는 방식이다.


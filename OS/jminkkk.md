### 운영체제란 무엇인가?

운영체제란 컴퓨터의 하드웨어를 관리하기 위한 소프트웨어 시스템을 말합니다.

보통 메모리 관리, 프로세스 관리, 자원 관리 등을 담당합니다. 


### 커널이란 무엇인가?

운영체제의 핵심 부분으로 직접 하드웨어에 대한 관리를 처리하는 핵심 소프트웨어

### 커널모드 vs 유저모드 (CPU의 실행모드)

커널에서 중요한 자원을 관리한다. 시스템에 영향을 미치는 중요한 연산과 그렇지 않은 연산을 분리해서 실행하는데, 이때 중요한 영향을 미치는 연산을 커널모드에서 실행한다.

- 커널 모드는 운영체제 코드나 디바이스 드라이버 같은 코드가 실행, 모든 자원에 접근이 가능
- 유저 모드는 유저 애플리케이션 코드가 실행되는 모드로, 유저가 접근할 수 있는 영역을 제한하고 자원에는 침범하지 못하도록 하는 것
  - 사용자 모드에서는 프로세스가 할당 받은 메모리에만 접근할 수 있음

> 유저모드 → 모드 비트 0
> 
> 사용자모드 → 모드 비트 1

### 시스템 콜

리소스가 필요한 작업 등 커널이 제공하는 기능을 사용하기 위해 커널이 제공하는 인터페이스로, 자원을 보호하는 것이 목적

실제 응용 프로그램이 실제 자원에 직접 접근하게 되면 자원에 영향이 갈 수 있음

시스템 콜을 기반으로 유저와 커널이 분리되는데, **시스템 콜이 호출될 경우 유저 모드에서 커널 모드의 영역으로 일시 전환**된다.
- 시스템 콜의 종류에는 프로세서 제어, 파일 조작, 장치 관리, 시스템 정보 및 자원 관리, 통신 등

### 시스템 콜 호출 시 어떻게 처리?

시스템 콜은 소프트웨어 인터럽트(트랩)다

1. 콜 요청
    - 시스템 콜 인자들(인덱스)를 CPU 레지스터에 저장
    - 인터럽트 발생
2. 사용자 모드에서 커널 모드로 전환
    - IDT(Interrupt Descriptor Table)를 참조하여 system_call()을 호출
    - 앞에서 저장한 인덱스를 system_call() 함수 내에 전달
3. 시스템 콜 처리
    - sys_call_table을 참조해 해당 인덱스에 맞는 기능(sys_write)을 호출
4. 결과 반환 및 복귀
    - 수행이 모두 끝나면 사용자 모드로 전환

### 인터럽트

**입출력 관리자가 CPU에게 보내는 완료 신호**

CPU가 작업을 실행할 때 모든 입출력 작업까지 처리하게 되면 비효율적이다.

따라서 이에 소요되는 시간을 줄이기 위해 입출력과 CPU을 독립적으로 운영하게 된다.

### 인터럽트 VS 트랩

인터럽트는 하드웨어 인터럽트, 소프트웨어 인터럽트로 나뉘며 주로 하드웨어 인터럽트를 인터럽트라고 명명

- 인터럽트: 외부에서 발생(하드웨어 인터럽트)
  - 입출력 장치, 하드웨어 고장, 전원 이상 등에 의해 발생
- 트랩: 내부에서 발생(소프트웨어 인터럽트)
  - 오버플로우, 불법적인 파일 접근 시도 등 프로그램 실행 중 특정 조건 발생 시 발생

### DMA(Direct Memory Access)

입출력 관련 작업을 할 때, CPU가 직접 입출력까지 처리하게 되면 효율적이지 못함

CPU가 입출력 매니저에게 입출력 관련 관련 권한을 위임하여 효율성을 높힌다.

원래는 CPU만 메모리에 접근이 가능한데, DMA를 사용하여 CPU를 거치지 않도록 함

즉, 직접 메모리와 입출력 장치 간에 직접 데이터를 전송할 수 있는 기능

### 프로세스란?

실행 중인 프로그램으로, 각각 독립된 메모리 공간을 가지는 실행 단위

PCB를 통해 관리되는 작업 단위

### 스레드

프로세스 내에서 실제로 작업을 실행하는 실행의 단위

스레드 간에는 코드, 데이터, 힙 영역을 공유하며, 스택만 독립적으로 사용할 수 있다.

### 멀티스레딩

하나의 프로세스 내에서 여러 스레드가 동시에 작업을 수행하는 것

공유자원에 대한 문제(교착 상태, 경쟁 조건)가 발생할 가능성이 있다.

멀티 프로세스에 비해 컨텍스트 스위칭 비용이 적다는 장점이 있다.

### 멀티 프로세싱

여러 개의 프로세스가 동시에 실행되는 것

### 멀티 스레드, 멀티 태스킹, 멀티 프로세싱

멀티 스레드: 하나의 프로세스 안에서 여러 개의 스레드가 동시에 작업을 수행

멀티 태스킹: 여러 작업을 동시에 수행하는 것처럼 보이도록 하는 시스템

멀티 프로세싱: 여러 개의 프로세서(CPU)가 여러 개의 프로세스를 동시에 처리

### 컨텍스트 스위칭

현재 실행 중인 프로세스/스레드의 상태를 저장하고 다음 프로세스/스레드를 실행하는 과정

- 실행 중인 프로세스/스레드의 상태를 저장하고
- 다음 실행할 프로세스/스레드의 상태를 복원하는 작업
- CPU가 다른 프로세스로 전환하는 과정

Process Context Switching 과정 = **커널 모드 전환** + **CPU register 상태 교체** + 가상 메모리 주소 처리(**MMU 수정** + **TLB 캐시 비우기**)

Thread Context Switching 과정 = **커널 모드 전환** + **CPU register 상태 교체**

### 리눅스 스케줄러 종류

장기: 어떤 프로세스를 Ready Queue**에 넣을 것인가**(Job Scheduler), 메모리에 올라갈 프로세스 선택

중기: 활성화된 프로세스 관리, 메모리 여유 공간 확보를 위한 스와핑

단기: CPU에서 실행할 다음 프로세스 선택, Ready Queue에서 프로세스 선택

### 프로세스의 상태

1. 생성 → PCB를 할당받은 상태
2. 준비 → 실행 단계 전, CPU를 할당 받기 위해 대기하는 상태
3. 실행 → CPU가 처리하고 있는 상태
4. 대기 → 입출력 관련 작업의 처리를 위해 실행 상태에서 대기 중인 상태
5. 종료 → 프로세스가 종료되는 상태

### 스케줄링 기법
1. FCFS (First Come First Served): 가장 단순한 스케줄링 방식, 먼저 도착한 프로세스를 먼저 처리하는 방식
2. SJF (Shortest Job First): 실행시간이 가장 짧은 프로세스 우선 실행
3. 우선순위 스케줄링
4. Round Robin: 시간 할당량(quantum)을 기준으로 프로세스 교체

### 선점형, 비선점형 스케줄링
선점형
- 운영체제가 강제로 프로세스 실행을 중단하고 다른 프로세스를 실행
- 우선순위가 높은 프로세스가 CPU를 차지
- 응답성이 좋음
- 문맥 교환 오버헤드가 큼

비선점형
- 프로세스가 자발적으로 CPU를 반납할 때까지 실행
- 문맥 교환 오버헤드가 적음
- 응답시간이 늦을 수 있음
- 우선순위가 높은 프로세스도 대기해야 함

### 동기와 비동기

**Synchronous** (동기) : 작업을 동시에 수행하거나, 동시에 끝나거나, 끝나는 동시에 시작함을 의미

**Asynchronous** (비동기) : 시작, 종료가 일치하지 않으며, 끝나는 동시에 시작을 하지 않음을 의미

### 프로세스(스레드) 동기화

자원의 일관성 보장을 위한 과정

- **1. 상호 배제 (mutual exclusion)**
    - 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 들어올 수 없다.
- **2. 진행 (progress)**
    - 임계 구역에 어떤 프로세스도 진입하지 않았다면 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
- **3. 유한 대기 (bounded waiting)**
    - 한 프로세스가 임계 구역에 진입하고 싶다면 언젠가는 임계 구역에 들어올 수 있어야 한다.
      
### **데드락**

여러개의 프로세스가 공유자원을 놓고 무한 대기하는 현상, 아래 4가지의 요소가 모두 발생해야 발생할 가능성이 있다.
1. 상호배제(Mutual Exclusion)
- 자원은 한 번에 한 프로세스만 사용 가능
2. 점유와 대기(Hold and Wait)
- 자원을 가진 상태에서 다른 자원 요청 가능
3. 비선점(No Preemption)
- 다른 프로세스의 자원을 강제로 빼앗을 수 없음
4. 순환 대기(Circular Wait)
- 프로세스간 자원 요청이 순환 형태를 이룸

데드락 처리 방법

1. 예방(Prevention)
- 4가지 발생 조건 중 하나를 제거
2. 회피(Avoidance)
- 자원 할당 자체를 피하는 방법
- unsafe, safe 중 safe 상태일 때만 자원을 할당하는 것
3. 탐지 및 복구(Detection & Recovery)
- 주기적으로 데드락 검사
- 발견 시 프로세스 강제 종료 등으로 복구
4. 무시(Ignorance)
- 데드락 발생을 무시

## [운영체제]

### 운영체제란 무엇인가?
운영체제는 컴퓨터 시스템의 하드웨어와 사용자 간의 중재자 역할을 하는 소프트웨어입니다.
사용자가 컴퓨터를 편리하게 사용할 수 있도록 응용 프로그램을 실행시키고 하드웨어 자원을 효율적으로 관리하며, 메모리, 파일 시스템, 네트워크, 보안 등의 자원 관리를 담당합니다.


### 커널이란 무엇인가?
커널은 운영체제의 핵심이며, 하드웨어와 직접 상호작용하는 역할을 합니다.
커널은 시스템의 자원을 할당하고 관리하는 기능을 담당하며, 메모리 관리, CPU 스케줄링, 장치 관리, 파일 시스템 등의 기능을 제공합니다.
이 커널 덕분에 애플리케이션은 하드웨어를 직접 제어할 필요 없이 OS를 통해 접근할 수 있습니다.


### 커널모드 vs 유저모드
- 커널 모드
  - 운영체제의 주요 기능을 수행하는 권한이 있는 모드로, 하드웨어 접근이나 시스템 자원 제어가 가능하지만, 안전성을 위해 보호된 모드입니다.
- 유저 모드:
  - 일반 애플리케이션이 실행되는 모드로, 제한된 권한만 있어 운영체제의 주요 기능에 직접 접근할 수 없습니다. 
  - 이로 인해 시스템의 안정성을 유지할 수 있습니다.


### 시스템 콜
시스템 콜은 사용자 모드에서 실행 중인 프로그램이 커널의 서비스를 요청할 때 사용됩니다.
예를 들어 파일을 열거나 네트워크에 연결하는 작업은 시스템 콜을 통해 커널에서 수행됩니다.
프로세스 관리, 파일 입출력, 네트워크 통신, 메모리 관리 등이 시스템 콜을 통해 이루어집니다.


### 인터럽트 vs 트랩
- 인터럽트
  - 외부 장치(예: 키보드, 마우스, 네트워크 카드 등)가 CPU에 작업 중단을 요청하는 신호입니다.
  - CPU는 인터럽트를 수신하면 현재 작업을 일시 중단하고, 요청된 인터럽트에 대응하는 작업을 수행합니다.
- 트랩
  - 소프트웨어적으로 발생하는 예외나 시스템 콜에 의해 발생하는 예외입니다
  - 예를 들어, 프로그램에서 오류가 발생하거나 특정 시스템 콜이 실행되면 트랩이 발생하여 예외 처리 루틴이 실행됩니다.


### DMA(Direct Memory Access)
DMA는 장치가 CPU의 개입 없이 메모리와 직접 데이터를 주고받는 방식입니다.
CPU는 명령을 내려 DMA가 데이터를 전송하도록 하고, 다른 작업을 수행할 수 있어 시스템 효율을 높입니다.


### 프로세스란?
프로세스는 실행 중인 프로그램을 말하며, CPU에서 실행되는 코드와 함께 메모리 공간, 파일 핸들, 환경 변수 등의 자원을 가집니다.
운영체제는 프로세스마다 별도의 메모리 공간을 할당하여 독립적인 실행 환경을 제공합니다.


### 스레드
스레드는 프로세스 내에서 실행되는 작업의 단위입니다.
프로세스가 자원을 독립적으로 관리하는 반면, 스레드는 프로세스의 자원을 공유하여 더 가벼운 실행 단위를 만들어줍니다.
멀티스레드 프로세스는 여러 스레드가 동시에 실행되어 자원을 효율적으로 사용할 수 있습니다.


### 멀티스레딩
하나의 프로세스가 여러 스레드를 만들어 동시에 여러 작업을 수행할 수 있는 방식입니다.
멀티스레딩을 통해 자원을 공유하므로 메모리 효율성을 높이며, 동시에 여러 작업을 처리할 수 있어 응답 시간을 줄입니다.


### 멀티 프로세싱
멀티 프로세싱은 여러 CPU나 코어를 이용해 동시에 여러 프로세스를 실행하는 방식입니다.
이는 시스템의 처리 속도를 향상시키며, 여러 작업을 동시에 수행하기 때문에 응답 시간이 빨라지고 시스템 성능이 높아집니다.


### 컨텍스트 스위칭
컨텍스트 스위칭은 CPU가 하나의 프로세스에서 다른 프로세스로 전환할 때 수행하는 작업입니다.
현재 실행 중인 프로세스의 상태(레지스터, 프로그램 카운터 등)를 저장하고, 다음에 실행할 프로세스의 상태를 복원하여 실행을 이어갑니다.
스위칭이 자주 발생하면 오버헤드가 커질 수 있습니다.


### 리눅스 스케줄러 종류
리눅스는 CFS(Completely Fair Scheduler)를 사용하는데, 프로세스에 공정하게 CPU 시간을 배분해줍니다.
CFS 외에도 오래된 O(1) 스케줄러가 있으며, 이는 프로세스를 고정 시간 내에 관리할 수 있는 구조를 가집니다.


### 프로세스의 상태
- 생성 상태 (New)
  - 프로세스가 처음 생성되었을 때의 상태입니다.
  - 이 단계에서는 운영체제가 프로세스의 초기화 작업을 진행하며, 메모리 할당, 프로세스 제어 블록(PCB) 생성 등을 수행합니다.
  - 생성 상태의 프로세스는 아직 실행 준비가 되지 않았고, 준비 상태로 전환하기 전 초기 설정을 마칩니다.
- 준비 상태 (Ready) 
  - 프로세스가 CPU 할당을 기다리고 있는 상태입니다.
  - 준비 상태에서는 실행에 필요한 메모리와 자원이 모두 할당되었으며, CPU를 받기만 하면 즉시 실행될 수 있습니다.
  - 운영체제의 스케줄러가 CPU를 할당해줄 때까지 준비 큐에서 대기합니다. 
- 실행 상태 (Running) 
  - 프로세스가 CPU를 할당받아 실제로 실행 중인 상태입니다.
  - 실행 상태에서는 CPU에서 명령어가 처리되고, 메모리에서 데이터를 읽고 쓰면서 작업을 수행합니다.
  - 한 번에 하나의 CPU는 오직 한 프로세스만을 실행할 수 있으므로, 여러 프로세스가 실행 상태로 전환되기 위해 경쟁합니다. 
- 대기 상태 (Waiting) 또는 블록 상태 (Blocked) 
  - 프로세스가 특정 이벤트가 발생하기를 기다리는 상태입니다. 
  - 예를 들어, 입출력 작업이 완료되기를 기다리거나 자원(예: 파일 잠금, 네트워크 응답 등)을 기다릴 때 대기 상태로 전환됩니다. 
  - 대기 상태에서는 CPU를 사용할 수 없으며, 이벤트가 발생하면 다시 준비 상태로 전환됩니다. 
- 종료 상태 (Terminated) 
  - 프로세스가 실행을 완료하거나 강제 종료된 상태입니다.
  - 종료 상태의 프로세스는 더 이상 CPU나 메모리를 점유하지 않으며, 운영체제가 프로세스가 사용하던 자원을 회수합니다.
  - 프로세스가 정상적으로 종료되거나 에러로 인해 비정상 종료되었을 때도 종료 상태로 들어갑니다.
- 대기 중 (Suspended) 또는 중지 상태 
  - 프로세스가 메모리에서 벗어나 하드디스크에 보관되며, 실행 대기 중인 상태입니다.
  - 시스템 자원이 부족하거나 우선순위가 낮아질 경우 운영체제는 프로세스를 일시 중단(suspend)하고, 나중에 필요할 때 메모리에 다시 적재해 준비 상태로 전환합니다. 

각 상태는 프로세스의 현재 상황을 나타내며, 스케줄러의 제어에 따라 다른 상태로 전환됩니다.


### 스케줄링 기법
- FCFS (First-Come, First-Served)
  - 먼저 도착한 프로세스를 먼저 처리합니다.
- SJF (Shortest Job First)
  - 실행 시간이 가장 짧은 프로세스를 우선 처리합니다.
- Round Robin
  - 프로세스마다 정해진 시간 동안만 CPU를 할당하고, 시간이 지나면 다음 프로세스로 전환합니다.

이외에도 우선순위 기반 스케줄링 등 다양한 기법이 있습니다.


### 동기와 비동기
- 동기
  - 작업이 순서대로 실행되며, 이전 작업이 완료될 때까지 대기합니다.
- 비동기
  - 작업이 동시에 실행되며, 이전 작업이 완료되기 전에도 다른 작업을 진행할 수 있습니다.
  - 비동기는 특히 I/O 작업에서 효율적입니다.


### 프로세스(스레드) 동기화
여러 프로세스나 스레드가 공유 자원을 안전하게 접근할 수 있도록 제어하는 방법입니다.
Mutex(뮤텍스), 세마포어 등의 동기화 기법을 사용하여 경쟁 조건을 방지하고 데이터 일관성을 유지합니다.


### 데드락
여러 프로세스가 서로 자원을 점유하며 무한정 대기하는 상황입니다.
데드락이 발생하려면 상호 배제, 점유와 대기, 비선점, 순환 대기의 조건이 모두 만족되어야 합니다.
이를 방지하려면 자원 할당 순서를 지키거나 자원 요청 시 타임아웃을 설정하는 등의 방법이 필요합니다.

- 상호 배제 (Mutual Exclusion)
  - 자원은 한 번에 하나의 프로세스만 사용할 수 있어야 합니다.
  - 즉, 공유 자원(예: 프린터, 파일 등)은 동시에 여러 프로세스가 사용할 수 없고, 특정 프로세스가 자원을 점유하면 다른 프로세스는 해당 자원을 사용할 수 없습니다. 
- 점유와 대기 (Hold and Wait)
  - 프로세스가 이미 할당받은 자원을 점유한 상태에서 다른 자원을 추가로 요청할 때, 요청한 자원이 할당될 때까지 대기합니다.
  - 이로 인해 자원을 점유한 상태에서 추가 자원을 기다리는 상황이 발생하며, 다른 프로세스들도 대기 상태에 빠질 가능성이 높아집니다.
- 비선점 (No Preemption)
  - 다른 프로세스가 점유하고 있는 자원을 강제로 빼앗을 수 없습니다.
  - 즉, 프로세스가 자원을 해제할 때까지 다른 프로세스는 해당 자원을 사용할 수 없습니다.
  - 이 때문에 자원이 해제될 때까지 기다려야 하는 상황이 발생할 수 있습니다.
- 순환 대기 (Circular Wait)
  - 프로세스들이 순환 형태로 자원을 요청하면서 기다리는 상태입니다. 
  - 예를 들어, 프로세스 A는 프로세스 B가 점유한 자원을 기다리고, 프로세스 B는 프로세스 C가 점유한 자원을 기다리며, 프로세스 C는 프로세스 A가 점유한 자원을 기다리는 상황이 발생합니다. 
  - 이렇게 순환 구조가 형성되면 각 프로세스가 자원을 해제하지 않는 한 대기 상태에서 벗어날 수 없습니다.

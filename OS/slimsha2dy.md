### 운영체제란 무엇인가?
    
    운영체제란 사용자가 컴퓨터를 사용하기 위해 필요한 시스템 소프트웨어이다.
    운영체제는 컴퓨터 자원을 관리하며 다양한 응용 프로그램이 안정적이고 효율적으로 실행될 수 있도록 한다.
    
### 커널이란 무엇인가?
    
    커널은 운영체제의 핵심 부분으로, 하드웨어 자원과 애플리케이션 간의 상호 작용을 관리하고 조정하는 역할을 한다.
    유저가 하드웨어를 직접 사용하지 않도록 하고 하드웨어 리소스를 관리한다.
    
### 커널모드 VS 유저모드
    
    커널이 cpu를 사용 중인 경우 커널 모드, 유저가 사용 중인 경우 유저 모드라고 한다.
    커널 모드에선 유저 모드와 달리 모든 자원에 접근, 명령을 할 수 있다.
    프로세스는 유저 모드와 커널 모드를 왔다 갔다 하면서 실행된다.
    이렇게 모드가 변경되는 것을 모드 스위칭이라 하며 각 CPU 내부에서 모드 비트를 통해 이 모드를 구분한다.
    
### 시스템 콜

    시스템 콜은 응용 프로그램이 운영체제의 서비스와 기능을 요청할 때 사용하는 인터페이스이다.
    유저 모드에서 실행되는 응용 프로그램이 커널 모드에서 실행되는 운영체제의 기능을 직접 구현하지 않고 안전하게 사용할 수 있도록 한다.
    하드웨어 자원 접근, 메모리 관리 등의 기능을 사용할 수 있다.
    
### 인터럽트 VS 트랩
    
    둘 다 유저 모드에서 커널 모드로의 모드 스위치를 발생시킨다.
    인터럽트는 외부 장치 또는 소프트웨어 인터럽트 요청에 의해 발생한다.
    타이머나 입출력 장치로 인한 하드웨어 인터럽트, 프로그램의 예외로 인한 소프트웨어 인터럽트가 있다.
    인터럽트가 발생하면 현재 실행 중인 프로세스는 중단되고 인터럽트 핸들러를 호출하여 작업을 수행한다.
    트랩은 소프트웨어 이벤트에 의해 발생하는 신호이다. 시스템 콜이나 예외 처리 상황에 발생한다.
    
### DMA(Direct Memory Access)
    
    하드웨어 장치가 CPU의 개입 없이 메모리와 직접적으로 데이터를 주고받을 수 있게 하는 기능이다.
    CPU가 해야 할 데이터 전송을 DMA 장치가 대신 해줌으로써 CPU 효율을 늘릴 수 있다.
    
### 프로세스란?
    
    프로세스는 수행 중인 프로그램이다. 즉, 프로그램이 실행되어 메모리에 올라온 상태.
    PCB의 형태로 커널에서 관리되며, image와 context로 나눌 수 있다.
    image는 우리가 실제로 올리는 코드와 자료구조이다. pc가 움직일 수 있는 영역으로, 코드 영역, 힙 영역 등으로 이루어졌다.
    context는 프로그램의 상태, 특성이라 할 수 있는데 이것도 두 개로 나뉜다.
    program context는 데이터 레지스터, pc, stack pointer 등이고, kenel context는 프로그램이 갖고 있는 고유의 특성으로 pid, gid, open files 등이 있다.
    
### 스레드
    
    프로세스를 더 작게 나눈 단위로, 실행 흐름의 최소 단위이다.
    각각 스택, 데이터 레지스터, pc를 독립적으로 갖고 있으며 같은 프로세스의 메모리(코드, 힙 영역 등)를 공유할 수 있다.
    
### 멀티스레딩
    
    여러 스레드가 동시에 실행되는 것. 같은 프로세스 안에서 코드와 힙 메모리의 데이터를 공유할 수 있다.
    따라서 공유 자원을 읽고 쓸 때 생길 수 있는 문제를 유의해야 한다. 멀티 프로세싱에 비해 스위칭 오버헤드가 적다.
    
### 멀티 프로세싱
    
    여러 프로세스가 동시에 실행되는 것. 각 프로세스는 독립적인 메모리 공간을 가지기 때문에 서로의 자원에 접근할 수 없다.
    서로 데이터를 공유하기 위해서는 IPC를 사용해야 한다.
    pipe, 공유 메모리, socket 등이 있다. 멀티스레딩에 비해 컨텍스트 스위칭 오버헤드가 크다.
    
### 컨텍스트 스위칭
    
    멀티 태스킹을 지원하기 위해 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 이전 프로세스 컨텍스트를 pcb에 저장하고 새로운 프로세스 컨텍스트를 적재하는 작업이다.
    컨텍스트 스위칭 중에 cpu는 다른 작업을 수행할 수 없으므로 오버헤드가 된다.
    
### 리눅스 스케줄러 종류
    - Long-Term 스케줄러: 시스템에 새로 생성된 프로세스를 레디 큐로 이동시키는 역할
        - 메모리 상의 프로세스를 조절하여 시스템의 부하를 조절
    - Short-Term 스케줄러: 레디 큐의 프로세스를 선택하여 실행하는 역할
        - 스케줄링 알고리즘을 통해 프로세스를 선택
    - Mid-Term 스케줄러: 프로세스를 스와핑하여 시스템의 메모리 자원을 관리
### 프로세스의 상태
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5abfc1c1-9cb1-494f-bd78-23fcb8cd8146/d2b6c742-f322-49c7-9c44-442ee955c8c1/image.png)
    new: 램으로 올라온 상태, PCB가 생성
    ready: CPU 할당을 기다리는 상태
    running: CPU에서 실행되고 있는 상태
    waiting/block: 특정 이벤트나 자원을 기다리는 상태. 입출력 작업을 대기하는 경우
    terminated: 실행이 완료되어 종료된 상태
    suspended: 디스크에 저장된 상태, swapping
    
### 스케줄링 기법
    - FCFS: 레디 큐의 가장 앞 프로세스를 실행하고 끝나면 다음을 실행하는 방식
        - 프로세스들이 오래 대기할 가능성이 높음
        - 한 프로세스가 CPU를 독점할 수 있음
    - Round Robin: 레디큐에 들어온 순서대로 실행하는데 타임 쉐어링을 해서 일정 시간이 지나면 다음 프로세스가 실행
        - 프로세스 간 스위칭이 많아짐
    - Priority: 우선 순위에 따라 스케줄링
    - SJF: 가장 짧은 것을 찾아서 먼저 실행
        - 평균적으로 대기 시간을 가장 줄일 수 있는 알고리즘
        - 누가 가장 짧을 지 알 수 없음
        - 실행 시간이 긴 프로세스가 계속 기다릴 수 있음
    - Multilevel queue
        - 시스템에 레디 큐가 여러 개
        - 각 큐마다 다른 스케줄링 알고리즘을 적용
    - Multilevel feedback queue
        - 프로세스 실행 패턴에 따라 큐 간 이동을 허용하는 방식
### 동기와 비동기
    
    동기란 작업이 순차적으로 실행되며, 이전 작업이 완료될 때까지 다음 작업이 대기하는 방식이다.
    순차적으로 실행되어야 하는 작업에 적합하지만 I/O 작업처럼 오래 대기해야 하는 작업이 있을 경우 비효율적일 수 있다.
    비동기란 작업이 독립적으로 실행되어 작업의 완료 여부와 상관 없이 다른 작업을 실행할 수 있는 방식이다.
    네트워크 요청이나 파일 작업 등을 비동기적으로 처리하여 응답 속도를 향상시킬 수 있다.
    
### 프로세스(스레드) 동기화
    
    한 자원에 여러 스레드가 동시에 접근하려고 하면 문제가 발생할 수 있다.
    이렇게 한 자원을 놓고 경쟁하는 상태를 race condition이라 하며, 동기화를 통해 이를 해결할 수 있다.
    아래의 3가지를 충족해야 한다.
    Mutual Exclusion: 임계 구역에는 하나만 접근할 수 있어야 함
    Progress: 임계 구역이 비어 있으면 접근할 수 있어야 함
    Bounded Waiting: 언젠가는 임계 구역에 접근할 수 있어야 함
    대표적인 방법으로 뮤텍스, 세마포어가 있다.
    뮤텍스는 처음 진입하는 스레드가 락을 획득하고 나갈 때 락을 반납하는 방식
    세마포어는 신호 체계로 세마포어 변수와 wait, signal 명령을 통해 스레드를 대기시키거나 대기 해제하는 방식
    
### 데드락
    
    데드락이란 서로 필요한 자원을 점유한 상태로 상대의 자원을 사용하기 위해 계속 대기하는 상태이다.
    아래 4가지가 동시에 만족하면 데드락이 발생할 수 있다.
    Mutual Exclusion: 한 명만 접근 가능
    Hold and Wait: 하나를 잡은 채로 대기할 때
    No preemption: 잡고 있을 때 뺏기지 않음
    Circular wait: 자원 할당 그래프가 사이클일 때
    회피, 예방, 탐지 및 회복으로 데드락을 해결할 수 있다.
    예방은 위 4가지 중 한 가지 조건을 False로 만드는 것
    회피는 런타임에 리소스 요청이 발생할 시 안전한 상태인지 확인하고 주는 것(Banker’s Algorithm)
    발생한 것을 확인하면 해당 프로세스 중 하나를 중지하는 식으로도 해결할 수 있다.

### 메모리 주소 바인딩

    각 프로세스는 독립적인 논리 주소를 사용하는데 이를 실제 물리 주소와 연결시키는 작업이 메모리 주소 바인딩이다. 세 가지 방식이 있다.
    컴파일 타임 바인딩: 컴파일 타임에 물리 메모리 주소가 결정된다. 다시 컴파일할 경우 메모리 주소가 변경된다.
    로드 타임 바인딩: 프로그램이 실행될 때 물리 메모리 주소가 결정된다. 로더가 메모리 주소를 부여하고 프로세스가 종료될 때까지 주소가 고정된다.
    실행 시간 바인딩: 프로그램이 실행한 후에도 물리 메모리 주소가 변경될 수 있다. CPU가 주소를 참조할 때마다 주소 매핑 테이블을 통해 바인딩을 점검한다.
    
### Swapping

    swapping은 운영체제에서 메모리 부족을 해결하기 위해 프로세스를 메모리에서 디스크의 스왑 영역으로 내보내고, 필요한 경우 다시 메모리로 불러오는 기법이다.
    디스크 입출력으로 인한 성능 저하가 발생할 수도 있다.
    
### 메모리 단편화
    
    메모리 단편화는 메모리 공간이 작은 조각으로 나뉘어 효율적으로 사용하지 못하는 현상이다.
    내부 단편화: 프로세스가 필요로 하는 공간보다 큰 메모리 블록을 할당 받을 때 남는 공간이 낭비되는 것. 고정 크기 메모리 할당에서 발생한다.
    외부 단편화: 메모리 공간이 불연속적으로 할당되어 사용하지 않는 작은 빈 공간이 메모리 여러 곳에 흩어지는 현상. 동적 크기 메모리 할당에서 발생한다.
    Compaction, 버디 시스템, 페이징, 세그멘테이션을 통해 이를 해결할 수 있다.
    
### 페이징
    
    paging은 메모리를 작은 크기의 프레임으로 나누고, 같은 크기로 나눈 프로세스의 페이지를 할당하는 메모리 관리 기법이다.
    이를 통해 프로세스가 연속된 메모리에 있지 않아도 실행 가능하도록 하며, 단편화 문제를 줄일 수 있다.
    다만 페이지 테이블 관리 및 메모리 접근 시 추가적인 오버헤드가 발생할 수 있다.
    
### 세그멘테이션
    
    segmentation은 프로세스를 서로 다른 크기의 논리적 단위로 나누어 관리하는 기법이다.
    논리적 단위는 프로세스 이미지의 코드, 힙, 스택 등으로 나뉘게 된다
    프로세스의 논리적 구조를 반영하여 관리할 수 있지만 외부 단편화 문제가 발생할 수 있다.

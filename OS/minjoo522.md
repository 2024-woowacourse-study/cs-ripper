### 운영체제란 무엇인가?

프로그램을 실행되기 위해서는 반드시 자원(CPU, 메모리, 보조기억장치 등)이 필요합니다. 이 때 필요한 자원들을 할당하고, 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램이 운영체제입니다.

운영체제는 응용 프로그램에 자원을 효율적으로 배분하고, 실행할 프로그램들이 지켜야 할 규칙을 만들어 컴퓨터 시스템 전체를 관리합니다.

### 커널(kernel)이란 무엇인가?

운영체제의 핵심 서비스를 담당하는 부분. 하드웨어와 소프트웨어 간의 상호작용을 관리합니다. 시스템 자원의 할당 및 관리를 수행하고 프로세스와 스레드 생성, 스케줄링, 종료 등을 담당합니다.

### 커널모드 vs 유저모드

#### 커널모드

운영체제 서비스를 제공받을 수 있는 실행 모드 즉, 커널 영역의 코드를 실행할 수 있는 모드입니다. CPU가 커널 모드로 명령어를 실행하면 자원에 접근하는 명령어를 비롯한 모든 명령어를 실행할 수 있습니다. 운영체제는 커널 모드로 실행되기 때문에 자원에 접근 할 수 있습니다.

#### 유저모드(사용자 모드)

운영체제 서비스를 제공받을 수 없는 실행 모드 즉, 커널 영역의 코드를 실행할 수 없는 모드입니다. 사용자 모드로 실행 중인 CPU는 입출력 명령어와 같이 하드웨어 자원에 접근하는 명령어를 실행할 수 없습니다. 일반적인 응용 프로그램은 기본적으로 사용자 모드로 실행되기 때문에 자원에 접근할 수 없습니다.

### 시스템 콜

유저모드로 실행되는 프로그램이 프로그램 자원에 접근하는 운영체제 서비스를 제공받으려면 운영체제에 요청을 보내 커널 모드로 전환되어야 합니다. 이 요청을 `시스템 호출(시스템 콜)`이라고 합니다. 시스템 호출은 일종의 **인터럽트**(소프트웨어 인터럽트 : 입출력장치에 의해 발생하는 게 아니라 인터럽트를 발생시키는 특정 명령어에 의해 발생하는 인터럽트)입니다.

1. 응용 프로그램은 하드 디스크에 데이터를 저장하는 시스템 호출을 발생시켜 커널 모드로 전환
2. 운영체제 내의 `하드 디스크에 데이터를 저장하는 코드` 실행해 하드 디스크에 접근
3. 하드 디스크 접근이 끝나면 다시 사용자 모드로 복귀

### 인터럽트 vs 트랩

컴퓨터 시스템에서 프로세스의 실행 흐름을 변경하거나 제어하는 중요한 메커니즘입니다.

#### 인터럽트

하드웨어 혹은 소프트웨어에 의해 발생하는 신호로 CPU의 현재 작업을 중단하고 특정 작업을 수행하도록 지시합니다.

- 하드웨어 인터럽트 : 외부 장치(키보드, 마우스 등)에서 발생합니다. 키보드를 눌렀을 때 하드웨어가 CPU에 신호를 보내 인터럽트를 발생시킵니다.
- 소프트웨어 인터럽트 : 프로그램이 특정 조건(시스템 콜)을 만족할 때 발생합니다.

1. 현재 실행 중인 프로세스의 상태를 저장합니다.
2. 인터럽트 서비스 루틴(ISR)을 호출해 인터럽트에 대한 처리를 수행합니다.
3. 이전 프로세스의 상태를 복원하고 다시 실행합니다.

#### 트랩

프로그램 내부에서 발생하는 예외 상황이나 특정 조건에 대한 신호로, 주로 소프트웨어에서 발생하며 시스템 호출을 수행하는 데 사용됩니다. 프로그램이 잘못된 메모리 접근이나 잘못된 연산을 수행할 때 바생합니다. 시스템 호출을 통해 운영체제의 서비스를 요청할 때도 트랩이 발생합니다.

1. 현재 프로세스의 상태를 저장합니다.
2. 트랩 핸들러(트랩 서비스 루틴)를 호출해 예외 상황을 처리합니다.
3. 프로그램이 정상적으로 계속 실행되도록 상태를 복원하거나 오류가 발생한 경우 프로세스를 종료합니다.

#### 차이점

인터럽트는 프로그램이 명시적으로 발생시킨다. 트랩은 프로그램 실행 중 발생하는 예외 상황이나 오류를 처리하기 위한 메커니즘이다.

### DMA(Direct Memory Access)

CPU를 거치지 않고 메모리와 입출력장치 간의 데이터를 주고받는 **입출력 방식**입니다. 입출력 장치가 메모리에 **직접적으로 접근**할 수 있습니다.

프로그램 입출력과 인터럽트 기반 입출력은 입출력장치와 메모리 간의 데이터 이동은 **CPU가 주도**하고 이동하는 데이터도 반드시 **CPU를 거칩니다**. 하드 디스크 백업과 같이 대용량 데이터를 이동한다면 CPU의 부담이 커집니다. 이런 문제를 해결하기 위해 등장한 기술입니다. DMA를 통해 CPU는 입출력 작업의 **시작과 끝**만 관여하게 됩니다.

DMA 컨트롤러라는 하드웨어를 통해 DMA를 할 수 있습니다.

1. CPU ➡️ DMA 컨트롤러에 입출력 작업을 명령합니다.
2. DMA 컨트롤러는 **CPU 대신 장치 컨트롤러와 상호작용**하며 입출력 작업을 수행합니다. (DMA 컨트롤러는 필요한 경우 메모리에 직접 접근합니다.)
3. 입출력 작업이 끝나면 DMA 컨트롤러가 인터럽트를 통해 CPU에 작업이 끝났음을 알립니다.

DMA 과정에서 시스템 버스를 이용하는데 **시스템 버스는 공용 자원**이기에 동시 사용이 불가능합니다. 즉, CPU가 시스템 버스를 사용할 때 DMA 컨트롤러는 시스템 버스를 사용할 수 없고 DMA 컨트롤러가 시스템 버스를 사용할 때 CPU가 시스템 버스를 사용할 수 없습니다. 그래서 DMA 컨트롤러는 아래와 같은 방법을 사용해 시스템 버스를 이용하게 됩니다. 그리고 이 양상을 **Cycle stealing**이라고 합니다.

1. CPU가 시스템 버스를 이용하지 않을 때마다 조금씩 시스템 버스를 이용합니다.
2. CPU가 일시적으로 시스템 버스를 이용하지 않돋록 허락을 구하고 시스템 버스를 이용합니다. (시스템 버스를 오래 사용해야 할 때)

장치컨트롤러가 시스템 버스에 직접 연결되는 것은 좋지 않다. (시스템 버스를 불필요하게 두 번(입력, 출력) 이용해야 하기 때문에) 이 문제를 방지하기 위해 **입출력 버스**라고 하는 입출력 전용 버스에 연결됩니다. (PCI 버스, PCI express 버스 등)

최근에는 입출력 전용 프로세서(입출력 채널)을 탑재하기도 한다. (입출력 작업 명령어 실행까지도 DMA 컨트롤러가 함)

### 프로세스란?

**실행 중인 프로그램**을 프로세스라고 합니다. 보조기억 장치에 저장된 프로그램을 메모리에 적재하고 실행하는 순간 그 프로램은 프로세스가 됩니다.

#### 포그라운드 프로세스(foreground process)

- 사용자가 볼 수 있는 공간에서 실행되는 프로세스

#### 백그라운드 프로세스(background process)

- 사용자가 볼 수 없는 공간에서 실행되는 프로세스
- 사용자와 상호작용하지 않고 그저 정해진 일만 수행하는 프로세스 (데몬, 서비스)

### 스레드

스레드는 **프로세스를 구성하는 실행의 흐름 단위**입니다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있습니다. 스레드를 이용하면 하나의 프로세스에서 여러 부분을 동시에 실행할 수 있습니다.

### 멀티스레딩

프로세스 내 작업을 여러 개의 스레드, 멀티스레드로 처리하기는 기법입니다. 스레드끼리 서로 자원을 공유하기 때문에(스레드들은 실행에 필요한 최소한의 정보만을 유지한 채 **프로세스 자원을 공유**) 효율성이 높습니다. 웹 요청을 처리할 때 새 프로세스를 생성하는 대신 스레드를 사용하는 웹 서버가 훨씬 적은 리소스를 소비하며, 한 스레드가 중단되어도 다른 스레드는 실행 상태일 수 있기 때문에 중단되지 않은 빠른 처리가 가능합니다.
하지만, 한 스레드에 문제가 생기면 다른 스레드에 영향을 끼쳐 프로세스에 영향을 줄 수 있다는 단점이 있습니다.

### 멀티 프로세싱

여러 프로세스를 동시에 실행하는 것입니다. 프로세스끼리는 자원을 공유하지 않지만, 스레드끼리는 같은 프로세스 내의 자원을 공유합니다. 프로세스를 fork하여 같은 자겁을 하는 동일한 프로세스 두 개를 동시에 실행하면 코드 영역, 데이터 영역, 힙 영역 등을 비롯한 모든 자원이 복제되어 메모리에 적재됩니다. (fork를 한 직후 같은 프로세스를 통째로 메모리에 중복 저장하지 않으면서 프로세스끼리 자원을 공유하지 않는 방법도 있다 - 쓰기 시 복사) 멀티프로세스 환경에서는 하나의 프로세스에 문제가 생겨도 다른 프로세스에 지장이 없습니다.

### 컨텍스트 스위칭(문맥 교환)

#### 프로세스 제어 블록(PCB : Process Control Block)

프로세스와 관련된 정보를 저장하는 자료 구조입니다. 상품에 달린 태그처럼 해당 프로세스를 식별하기 위해 꼭 필요한 정보들이 저장됩니다. PCB는 커널 영역에 생성됩니다. 운영체제는 여러 프로세스 사이에서 PCB로 특정 프로세스를 식별하고 처리하는 데 필요한 정보를 판단합니다. (프로세스 ID, 레지스터 값, 프로세스 상태, CPU 스케줄링 정보, 메모리 관리 정보 등이 저장됩니다.)

#### 컨텍스트 스위칭(싱글 코어 기준 설명)

프로세스 수행을 재개하기 위해 기억해야할 정보를 문맥(context)이라고 합니다. 이는 PCB에 기록되어 있습니다. 기존 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구해 새로운 프로세스를 실행하는 것을 컨텍스트 스위칭이라고 합니다. 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생합니다. 많은 프로세스가 동시에 구동되는 것 처럼 보이는 것은 다른 프로세스와의 컨텍스트 스위칭이 아주 빠른 속도로 실행되기 때문입니다.

### 리눅스 스케줄러 종류 -> ????

크게 장기 스케줄러, 단기 스케줄러, 중기 스케줄러로 분류됩니다.

#### 장기 스케줄러(Long-Term Scheduler)

작업 스케줄러(Job Scheduler)라고 부르기도 합니다. 생성되기를 원하는 프로세스들 중에 어떤 프로세스를 생성할 것인지 결정하는 스케줄러입니다. 시스템의 리소스를 사용할 자격이 있는지 결정합니다. 프로그램을 프로세스로 생성할지 결정합니다.
프로세스의 수를 조절하여, 멀티 프로그래밍의 정도를 관리합니다. 시스템 내의 적당한 개수의 프로세스가 유지되도록 하는 것이 장기 스케줄러의 목적입니다. 시스템의 상태에 따라 조절되며 실행됩니다.

#### 단기 스케줄러(Short-Term Scheduler)

디스패처(dispatcher)라고도 부릅니다. 준비상태에서 대기중인 프로세스들 중에 어떤 프로세스를 실행단계로 옮길지 결정하고 이 작업을 디스패치(dispatch)라고 부릅니다. 실행할 모든 준비가 다 된 메모리에 있는 프로세스 중에서 어떤 프로세스를 CPU가 다음으로 실행할지 결정합니다.
CPU의 효율적 사용을 보장하고 컨텍스트 스위칭을 관리합니다. 매번 실행상태의 프로세스가 바뀔 때마다 발생합니다.

#### 중기 스케줄러(Medium-Term scheduler)

시스템의 성능을 향상시키기 위해 프로세스를 메모리와 스왑 공간(디스크) 사이에서 이동시키는 스와핑(Swapping)을 합니다.
메모리 사용의 효율성을 높이고 멀티프로그래밍 정도를 동적으로 조정합니다. 시스템의 메모리 요구와 상태에 따라 조절됩니다.

### 프로세스의 상태

생성, 준비, 실행, 대기, 종료 상태. 컴퓨터 내의 여러 프로세스는 생성, 준비, 실행, 대기, 종료 상태를 거치며 실행됩니다.

#### 생성 상태(create)

프로세스가 생성된 상태로 `fork()` 또는 `exec()` 함수를 통해 생성합니다. 이 때 PCB가 할당됩니다. 생성 상태를 거쳐 실행할 준비가 완료된 프로세스는 곧바로 실행되지 않고 준비 상태가 되어 CPU 할당을 기다립니다.

##### fork()

부모 프로세스의 주소 공간을 그대로 복사하며, 새로운 자식 프로세스를 생성하는 함수입니다. 주소 공간만 복사할 뿐 부모 프로세스의 비동기 작업 등을 상속하지 않습니다.

##### exec()

새롭게 프로세스를 생성하는 함수입니다.

#### 준비 상태(ready)

당장이라도 CPU를 할당받아 실행할 수 있지만, 아직 차례가 아니기에 기다리고 있는 상태입니다. 준비 상태 프로세스는 차례가 되면 CPU를 할당받아 실행 상태가 됩니다. (디스패치 : 준비 상태 프로세스가 실행 상태로 전환되는 것)

#### 실행 상태(running)

CPU를 할당받아 실행 중인 상태입니다. 할당된 일정 시간 동안만 CPU를 사용할 수 있습니다. 프로세스가 할당된 시간을 모두 사용하면(타이머 인터럽트 발생) 다시 준비 상태가 되고, 실행 도중 입출력장치를 사용해 입출력 장치 작업이 끝날 때까지 기다려야 한다면 대기 상태가 됩니다.

#### 대기 상태(blocked)

입출력장치의 작업을 기다리는 상태입니다. 입출력 작업이 완료되면 다시 준비 상태로 CPU 할당을 기다립니다. 입출력 작업만이 이유는 아니고 특정 이벤트가 일어나길 기다릴 때 프로세스는 대기 상태가 됩니다. 대기 상태가 되는 대부분의 원인이 입출력 작업입니다.

#### 종료 상태(terminated)

프로세스가 종료된 상태입니다. 운영체제는 PCB와 프로세스가 사용한 메모리를 정리합니다.

### 스케줄링 기법

운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것을 CPU 스케줄링이라고 합니다. 프로세스들에게 현명하게 CPU를 배분하지 못하면 반드시 실행되어야 할 프로세스들이 실행되지 못하거나, 당장 급하지 않은 프로세스들만 주로 실행되는 등 무질서한 상태가 발생할 수도 있습니다.

#### 비선점형 방식(non-preemptive)

프로세스가 스스로 CPU 소유권을 포기하는 방식이며, 강제로 프로세스를 중지하지 않습니다. 컨텍스트 스위칭으로 인한 부하가 적습니다.

##### FCFS(First Come, First Served)

선입 선처리 스케줄링. 가장 먼저 온 것을 가장 먼저 처리하는 알고리즘입니다. 길게 수행되는 프로세스 때문에 '준비 큐에서 오래 기다리는 현상(호위 효과, convoy effect)'이 발생할 수 있습니다.

##### 최단 작업 우선(SJF, Shortest Job First)

CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식. 긴 시간을 가진 프로세스가 실행되지 않는 현상(starvation)이 일어나며 평균 대기 시간이 가장 짧습니다. 하지만 실제로는 실행 시간을 할 수 없기 때문에 과거 실행했던 시간을 토대로 추측해서 사용합니다.

##### 우선순위

프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘입니다. (우선순위가 같은 프로세스들은 선입 선처리로 스케줄링됩니다.)
우선순위가 낮은 프로세스는 준비 큐에 먼저 삽입되었음에도 불구하고 실행이 계속해서 연기될 수 있습니다(기아 stracation 현상)
기아현상을 방지하기 위한 대표적인 기법으로 **에이징**이 있습니다. 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식입니다.

#### 선점형 방식(preemptive)

현대 운영체제가 쓰는 방식입니다. 사용하고 있는 프로세스를 알고리즘에 의해 중단시켜 버리고 강제로 다른 프로세스에 CPU 소유권을 할당하는 방식을 말합니다.

##### 라운드 로빈(RR, Round Robin)

FCFS 스케줄링에 타임 스라이스라는 개념이 더해진 스케줄링 방식입니다.
각 프로세스는 동일한 할당 시간을 주고 그 시간안에 끝나지 않으면 다시 큐(ready queue)의 뒤로 가는 알고리즘입니다.
타임 슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미합니다.
타임 슬라이스 크기가 매우 중요합니다. 타임 슬라이스 크기가 너무 크면 FCFS가 되어 호위 효과가 생길 여지가 있고 짧으면 컨텍스트 스위칭이 잦아져서 오버헤드, 즉 비용이 커집니다.(프로세스를 전환하는 데 더 많은 힘을 쓸 여지가 있습니다.)

##### 최소 잔여 시간 우선(SRF, Shortest Remaining Time First)

최단 작업 우선 스케줄링(SJF)과 라운드 로빈 알고리즘을 합친 스케줄링 방식입니다.
정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스는 남아있는 작업 시간이 가장 적은 프로세스가 선택됩니다.

##### 다단계 큐

우선순위 스케줄링의 발전된 형태입니다. 우선순위별로 큐를 여러 개 사용하는 스케줄링 방식입니다.
우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 가장 높은 큐가 비어 있으면 그 다음 우선순위 큐에 있는 프로세스들을 처리합니다.
큐를 여러 개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해집니다. 큐별로 타임 슬라이스를 여러 개 지정할 수도 있고, 큐마다 다른 스케줄링 알고리즘을 사용할 수 있습니다.
큐 간의 프로세스 이동이 안 되므로 스케줄링 부담이 적지만 유연성이 떨어진다는 단점이 있습니다.

### 동기와 비동기

#### 동기(Synchronous)

작업을 순차적으로 진행하며, 이전 작업이 완료돼야 다음 작업이 시작됩니다. 코드가 순서대로 실행되고, 하나의 작업이 완료될 때까지 다른 작업이 기다립니다.

#### 비동기(Asynchronous)

작업이 완료될 때까지 기다리지 않고, 다른 작업을 병렬로 처리합니다. 작업을 시작하고, 그 결과가 나중에 준비되면 이를 처리하는 방식입니다. `콜백`, `이벤트` 또는 `Promise`와 같은 방식을 통해 완료 상태를 알립니다.
네트워크 요청, 대용량 파일 처리 등 시간이 걸리는 작업에 주로 사용됩니다.

### 프로세스(스레드) 동기화

(실행의 흐름을 갖는 모든 것은 동기화의 대상입니다.)
프로세스 사이의 수행 시기를 맞추는 것을 의미합니다. 동기화에는 실행 순서 제어를 위한 동기화가 있고, 상호 배제를 위한 동기화가 있습니다.

- 실행 순서 제어 : 프로세스를 올바른 순서대로 실행하기
- 상호 배제 : 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기

#### 실행 순서 제어를 위한 동기화

![[Pasted image 20241106013121.png]]
Writer 프로세스가 Book.txt 파일에 값을 저장하고, Reader 프로세스가 Book.txt 파일에 저장된 값을 읽어 들이는 프로세스라면 Reader 프로세스는 Writer 프로세스가 수행된 뒤 실행되어야 합니다. 동시에 실행되는 프로세스를 올바른 순서대로 실행하는 것이 첫 번째 프로세스 동기화입니다.

#### 상호 배제를 위한 동기화

상호 배제(mutual exclusion)는 공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘입니다.
프로세스 A가 계좌의 잔액을 읽어 들이고 ➡️ 읽어 들인 잔액에 2만 원을 더하고 ➡️ 더한 값을 저장합니다.
프로세스 B는 계좌의 잔액을 읽어 들이고 ➡️ 읽어 들인 잔액에 5만 원을 더하고 ➡️ 더한 값을 저장합니다.
프로세스 A가 잔액에 2만 원을 더하고(10 + 2) 더한 값을 저장하기 `전`에 컨텍스트 스위칭이 일어나 프로세스 B가 잔액을 읽어 들이고 읽어 들인 잔액에 5만 원을 더합니다(10 + 5). 그리고 다시 컨텍스트 스위칭이 일어나 프로세스 A가 더한 값을 저장합니다. 또 컨텍스트 스위칭이 일어나 다시 프로세스 B가 더한 값을 저장한다면 최종 잔액이 17만 원이 아닌 15만 원이 됩니다.
A, B를 올바르게 실행하기 위해서는 한 프로세스가 잔액에 접근했을 때 다른 프로세스는 기다려야 합니다.
동시에 접근해서는 안 되는 자원에 동시에 접근하지 못하게 하는 것이 상호 배제를 위한 동기화입니다.

### 데드락

> **식사하는 철학자 문제**
> 철학자들 앞에는 맛있는 식사가 있고, 사이 사이에 포크가 있습니다. 철학자들 앞에 있는 식사는 두 개의 포크로 먹을 수 있는 음식입니다.![[Pasted image 20241106014355.png]] > `1` 계속 생각을 하다가 왼쪽 포크가 사용 가능하면 집어든다.
> `2` 계속 생각을 하다가 오른쪽 포크가 사용 가능하면 집어든다.
> `3` 왼쪽과 오른쪽 포크를 모두 집어들면 정해진 시간동안 식사를 한다.
> `4` 식사 시간이 끝나면 오른쪽 포크를 내려놓는다.
> `5` 오른쪽 포크를 내려놓은 뒤 왼쪽 포크를 내려놓는다.
> `6` 다시 `1`번부터 반복한다.

➡️ 모든 철할자가 동시에 포크를 집어 식사를 하면 어떤 철학자도 식사를 할 수 없고 영원히 생각만 하는 상황이 발생할 수 있습니다. 모든 철학자가 왼쪽 포크를 집어들면 모두가 오른쪽 포크를 집어들 수 없기 때문입니다.

일어나지 않을 사건을 기다리며 진행이 멈춰 버리는 현상을 교착 상태(deadlock)이라고 합니다.

교착 상태가 발생한 자원은 자원 할당 그래프가 원의 형태를 띄고 있습니다.

#### 교착 상태 발생 조건

교착 상태가 발생할 조건에는 `상호 배제, 점유와 대기, 비선점, 원형 대기` 네 가지 조건이 있습니다. 네 조건 중 하나라도 만족하지 않는다면 교착 상태가 발생하지 않지만, 모두 만족될 때 교착 상태가 발생할 가능성이 생깁니다.

##### 상호 배제

한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상호 배제 상황에서 교착 상태가 발생할 수 있습니다.

##### 점유와 대기

어떠한 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다린다면 교착 상태가 발생할 수 있습니다. 그리고 이 상태를 점유와 대기라고 합니다.

##### 비선점

비선점 자원은 그 자원을 이용하는 프로세스의 작업이 끝나야만 비로소 이용할 수 있습니다. 즉, 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못해서 교착 상태가 발생할 수 있습니다.

##### 원형 대기

자원 할당 그래프가 원의 형태로 그려지면 교착 상태가 발생할 수 있습니다. (원의 형태를 띈다고 해서 반드시 교착 상태 발생하는 것은 아님)

#### 교착 상태 예방

상호 배제, 점유와 대기, 비선점, 원형 대기 중 하나의 조건이라도 만족시키지 않게 할당하면 교착 상태는 발생하지 않습니다.

##### 상호 배제

모든 자원을 공유 가능하게 만듭니다. 하지만, 현실적으로 모든 자원의 상호 배제를 없애기는 어렵기에 현실에서 사용하기에 무리가 있습니다.

##### 점유와 대기

점유와 대기를 없애면 운영체제는 특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지 않는 방식으로 배분합니다. 자원의 활용률이 낮아질 우려가 있습니다. 당장 자원이 필요해도 기다릴 수 밖에 없는 프로세스와 사용되지 않으면서 오랫동안 할당되는 자원을 다수 양산할 수 있습니다.
많은 자원을 사용하는 프로세스가 불리해집니다. 자원을 적게 사용하는 프로세스에 비해 동시에 자원을 사용할 타이밍을 확보하기 어렵기 때문입니다. 많은 자원을 필요로 하는 프로세스가 무한정 기다리게 되는 기아 현상을 야기할 수 있습니다.

##### 비선점 조건

선점해 사용할 수 있는 일부 자원에 대해서는 효과적입니다. 하지만 모든 자원이 선점 가능한 것은 아닙니다.
예를 들어 한 번에 하나의 프로세스만 이용 가능한 프린터 자원이 있다면 프로세스가 이 프린터를 이용하는 도중에 다른 프로세스가 프린터 자원을 빼앗아 사용하기 어렵습니다. 그래서 비선점 조건을 없애 모든 자원을 빼앗을 수 있도록 하는 방법은 범용성이 떨어집니다.

##### 원형 대기 조건

모든 자원에 번호를 붙이고, 오름차순으로 자원을 할당합니다.
모든 컴퓨터 시스템 내에 존재하는 수많은 자원에 번호를 붙이는 일이 간단하지 않고 각 자원에 어떤 번호를 붙이는지에 따라 특정 자원의 활용률이 떨어질 수 있습니다.

#### 교착 상태 회피

교착 상태가 발생하지 않을 정도로만 조심 조심 자원을 할당하는 방식입니다. 프로세스들에 배분할 수 있는 자원의 양을 고려해 교착 상태가 발생하지 않을 정도의 양만큼만 자원을 배분합니다.
시스템 상태가 안전 상태에서 안전 상태로 움직이는 경우에만 자원을 할당합니다.

#### 교착 상태 검출 후 회복

교착 상태 발생을 인정하고 사후에 조치하는 방식입니다. 운영체제는 프로세스들이 자원을 요구할 때마다 그때그때 모두 할당하며, 교착 상태 발생 여부를 주기적으로 검사합니다.

##### 선점을 통한 회복

교착 상태가 해결될 때까지 한 프로세스씩 자원을 몰아주는 방식입니다. 교착 상태가 해결될 때까지 다른 프로세스로부터 자원을 강제로 빼앗고 한 프로세스에 할당하는 방식입니다.

##### 프로세스 강제 종료를 통한 회복

가장 단순하면서 확실한 방식입니다. 교착 상태에 놓인 프로세스를 모두 강제 종료하거나 교착 상태가 없어질 때까지 한 프로세스씩 강제 종료합니다.
많은 프로세스들이 작업 내역을 잃게 될 가능성이 있고, 교착 상태가 없어졌는지 여부를 확인하는 과정에서 오버헤드가 발생할 수 있습니다.

> **타조 알고리즘(ostrich algorithm)**
> 교착 상태 아예 무시 / 드물게 발생하는 잠재적 문제를 무시로 대처하는 방식

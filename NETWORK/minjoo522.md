# 네트워크

### 브라우저에 URL을 입력했을 때 무슨 일이 일어날까?

1. 웹 브라우저에 URL을 입력하고 Enter 키 입력
2. 웹 브라우저가 도메인명의 IP 주소 조회
   - 브라우저가 인터넷에서 연결할 서버를 파악한다.
   - DNS 조회를 사용해 웹 사이트를 호스팅하는 서버의 IP 주소를 조회한다.
   - DNS는 복잡하고 빨라야하기 때문에 웹 브라우저 사이의 서로 다른 계층과 인터넷의 다양한 위치에 임시로 저장된다. (캐시, Cache)
     - host(/etc/hosts) 파일에 정보가 있는지 먼저 읽는다.
     - 고유한 캐시, 운영 체제 캐시, 라우터의 로컬 네트워크 캐시, 회사 네트워크, 인터넷 서비스 제공업체의 DNS 서버 캐시를 확인한다.
   - 캐시 계층에서 IP 주소를 찾을 수 없는 경우 재귀적 DNS 조회를 수행한다.
     - 인터넷에 있는 여러 DNS 서버를 요청해 검색될 때까지 DNS 레코드에 대해 더 많은 DNS 서버에 요청한다.
3. 웹 브라우저가 서버와의 TCP 연결 시작
   - TCP/IP(Transmission Control Protocol/Internet Protocol) 전송 제어 프로토콜을 사용해 연결할 IP 주소가 있는 웹 서버를 찾습니다.
   - 웹 서버에 직접 도달하는 방법은 위치에 따라 효율적이지 않을 수 있습니다. -> 직접 서버에 연결하기 보다는 CDN(콘텐츠 전송 네트워크)을 사용해 정적 및 동적 콘텐츠를 웹 브라우저 가까이에 위치 시킵니다.
   - CDN(콘텐츠를 사용자에게 더 가까이 제공해서 사이트의 원본 연결 성능을 개선하는 캐싱 서버의 글로벌 분산 네트워크)
   - HTTP를 통해 평문 통신 시작 / HTTPS 사용 시 TLS(Transport Layer Security) 핸드셰이크 추가 수행
4. 웹 브라우저가 HTTP 요청을 서버로 전송
5. 웹 서버가 요청을 처리하고 응답을 다시 전송
6. 웹 브라우저가 콘텐츠 렌더링

### Ethernet

같은 지역의 네트워크인 LAN을 유선으로 구현하는 기술 방식, 네트워크 통신의 가장 근본이 되는 신호와 케이블부터 전기 신호를 데이터로 변환하는 프로토콜까지 LAN을 구현하는 큰 흐름을 규격화한 기술입니다.

- 네트워크 만들기 키트나 안내서
- 설치하는 데 드는 비용이 적고 속도도 빠르다 -> 대부분의 유선 인터넷 환경에서 사용하고 있다.

### CSMA

- Carrier Sense Multiple Access
- 네트워크에서 여러 장치가 동일한 전송 매체를 공유할 때 충돌을 방지하거나 줄이기 위해 사용되는 통신 프로토콜
- 장치가 데이터를 전송하기 전에 채널의 상태를 확인해 채널이 사용 중인지 또는 비어 있는지 판단합니다.

#### 작동 원리

1. Carrier Sense (캐리어 감지)
   - 데이터를 전송하려는 장치는 현재 네트워크 채널을 모니터링해 다른 장치가 데이터를 전송하고 있는지 확인합니다.
   - 채널이 사용 중인 경우, 장치는 대기합니다.
2. Multiple Access (다중 접속)
   - 네트워크의 여러 장치가 동일한 전송 매체에 동시에 액세스할 수 있는 환경을 의미하비단.
3. Collision Handling (충돌 처리)
   - 두 장치가 동시에 데이터를 전송하면 충돌이 발생할 수 있습니다.

### IPv4에서 주소 부족 문제의 이유와 해결법

IPv4 주소는 32비트로 구성되어 있어 약 43억 개의 주소를 제공합니다. 인터넷 사용자가 급격히 증가하면서 이 주소 공간이 부족하게 되었습니다. 개인용 컴퓨터, 스마트폰, IoT 장치 등 인터넷에 연결되는 디바이스의 증가로 주소 수요가 급증했습니다.

#### 해결

1. 네트워크 주소 변환 (NAT, Network Address Translation)
   - 내부 네트워크에서 사용하는 사설 IP 주소를 공인 IP 주소로 변환해 인터넷과 통신하도록 합니다.
   - 사설 네트워크와 외부 네트워크 간의 직접적인 통신을 제한하며, 설정 및 유지 관리가 복잡할 수 있습니다.
2. 사설 IP 주소 사용 (Private IP Address)
   - 사설 네트워크 내부에서 사용하는 IP 주소를 정의해 공인 IP 주소를 절약합니다.
3. CIDR (Classless Inter-Domain Routing)
   - 기존 클래스 기반 주소 체계(A, B, C 클래스) 대신 유연한 주소 할당 방식 도입
4. IPv6 도입 - 128비트 주소 체계를 사용해 사실상 무제한에 가까운 주소를 제공합니다. - 모든 기기에 고유한 IP 주소를 제공할 수 있습니다. - 향상된 보안 및 네트워크 관리 기능도 제공합니다.
   장기적으로는 IPv6로 완전히 전환하는 것이 근본적인 해결책이지만, IPv4와의 공존 및 전환 과정이 필요합니다.

### 라우팅 프로토콜에서 Distance Vector vs Link State

- 네트워크 라우팅 프로토콜에서 사용되는 두 가지 주요 알고리즘

#### Distance Vector Routing

- 거리를 기준으로 경로를 결정하는 방식
- 자신과 연결된 이웃에게 네트워크 거리 정보를 주기적으로 전송하며 이를 기반으로 최적 경로를 계산합니다.

##### 작동 방식

- 라우터가 이웃 라우터로들로부터 거리 정보를 수신하고 자신의 경로 테이블에 반영합니다.
- `벨만-포드 알고리즘`을 사용해 최적 경로를 계산합니다.

##### 장점

- 구현이 간단하고 계산이 비교적 덜 복잡합니다.
- 소규모 네트워크에 적합합니다.

##### 단점

- 네트워크 변화가 발생했을 때 전체 네트워크가 새로운 경로로 업데이트되는 데 시간이 오래 걸릴 수 있습니다.
- 경로에 장애가 발생했을 때 무한히 큰 거리로 계속 업데이트되는 문제가 발생할 수 있습니다.
- 대규모 네트워크에서 비효율적입니다.

#### Link State

- 네트워크 전체의 상태 정보를 사용해 각 라우터가 네트워크의 완전한 맵을 구축한 후 최적 경로를 계산하는 방식

##### 작동 방식

- 라우터는 네트워크 전체 링크 상태 정보를 수집해 다익스트라 알고리즘을 사용해 최적 경로를 계산합니다.
- 링크 상태 광고(LSA, Link State Advertisement)를 통해 네트워크 전체로 정보를 브로드캐스트합니다.

##### 장점

- 네트워크 변화에 신속히 반응하여 새로운 최적 경로를 계산합니다.
- 네트워크 맵을 기반으로 경로 계산 -> 경로 루프가 발생하지 않습니다.
- 대규모 네트워크에서도 효율적입니다.

##### 단점

- 계산과 저장 공간의 부담이 큽니다.
- 구현이 복잡합니다.

### TCP

- Transmission Control Protocol
- 인터넷에서 데이터 통신을 안정적으로 관리하기 위해 사용되는 연결 지향형 통신 프로토콜
- OSI 7 계층 모델에서 전송 계층(Transport Layer)에 속하며 데이터의 신뢰성과 순서 보장을 제공합니다.

#### 특징

1. 연결 지향
   - 데이터를 전송하기 전에 송신자와 수신자가 3-way handshake를 통해 연결을 설정합니다.
   - 연결 종료 시에는 4-way handshake를 통해 연결을 해제합니다.
2. 신뢰성 있는 데이터 전송
   - 데이터를 전송할 때 손실된 패킷은 재전송합니다.
   - 데이터가 올바른 순서로 도착하도록 보장하며, 패킷 순서가 어긋나면 재정렬합니다.
3. 흐름 제어
   - 송신자가 데이터를 너무 빠르게 보내는 것을 방지해 수신자가 처리 가능한 데이터만 받도록 조율합니다.
4. 혼잡 제어
   - 네트워크가 과부하 상태에 빠지지 않도록 데이터 전송 속도를 조절합니다.
5. 패킷 확인 및 재전송
   - 송신자는 데이터 전송 후 ACK(응답)를 기다립니다. 응답이 없으면 데이터를 다시 전송합니다.

### TCP handshaking

#### `1` 연결 설정 (3-Way Handshake)

- TCP 연결을 시작하기 위해 송신자와 수신자는 다음 세 단계를 거칩니다.
- **SYN** : 송신자가 연결 요청 신호를 보냅니다.
- **SYN-ACK** : 수신자가 요청을 확인하고 응답합니다.
- **ACK** : 송신자가 응답을 확인하며 연결이 설정됩니다.

#### `2` 데이터 전송

- 데이터를 작은 조각(세그먼트)으로 나눠 전송합니다.
- 수신자는 각 세그먼트를 확인(ACK)하고, 누락된 세그먼트가 있으면 요청해 재전송 받습니다.
- 송신자는 수신자의 처리 속도에 맞춰 데이터를 전송합니다.

#### `3` 연결 종료 (4-Way Handshake)

- TCP 연결을 종료할 때는 다음 단계를 거칩니다.
- **FIN** : 송신자가 연결 종료 요청을 보냅니다.
- **ACK** : 수신자가 이를 확인합니다.
- **FIN** : 수신자도 연결 종료 요청을 보냅니다.
- **ACK** : 송신자가 이를 확인하며 연결이 해제됩니다.

### TCP Error Control

- TCP는 신뢰성 있는 데이터 전송을 보장하기 위해 오류 제어 메커니즘을 제공합니다.
- 데이터 손실, 중복, 순서 뒤바뀜, 데이터 손상 등을 처리해 수신자가 올바른 데이터를 받을 수 있도록 돕습니다.

#### Error Control 기법

1. 체크섬(Checksum)
   - 송신자는 TCP 세그먼트를 전송하기 전에 헤더와 데이터의 1의 보수 합계를 계산해 체크섬 필드에 저장합니다.
   - 수신자는 세그먼트를 수신한 후 체크섬을 재계산해 송신자의 값과 비교합니다.
     - **값이 다르면 오류 발생**으로 간주하고 세그먼트를 폐기합니다.
2. ACK(Acknowledgment, 확인 응답)
   - 송신자는 ACK를 수신하면 해당 데이터가 정상적으로 전달되었음을 확인합니다.
   - ACK가 수신되지 않으면 송신자는 데이터를 **재전송**합니다.
3. 타이머와 재전송(Retransmission)
   - 송신자는 데이터 전송 후 응답(ACK)을 기다립니다.
   - 지정된 시간(타임아웃) 내에 ACK를 받지 못하면 해당 세그먼트를 재전송합니다.
   - 재전송 타이머는 네트워크 상태에 따라 적응적으로 조정됩니다.
4. 시퀀스 번호(Sequence Number)
   - TCP 세그먼트마다 고유한 시퀀스 번호를 부여해 데이터 순서를 추적합니다.
   - 수신자는 시퀀스 번호를 통해 데이터의 순서를 확인하고 누락된 데이터가 있는지 감지합니다.
   - 누락된 세그먼트는 송신자에게 재전송 요청됩니다.
5. 슬라이딩 윈도우와 중복 ACK
   - 슬라이딩 윈도우 기법을 사용해 네트워크를 효율적으로 관리하면서 오류를 처리합니다.
   - 중복 ACK
     - 동일한 데이터에 대해 여러 번 ACK를 받으면, 수신자는 일부 데이터가 누락되었음을 암시합니다.
     - 송신자는 중복 ACK를 통해 손실된 세그먼트를 빠르게 재전송합니다.
6. 패킷 순서 재조합
   - 데이터가 순서대로 도착하지 않은 경우, 수신자는 시퀀스 번호를 기준으로 데이터를 재조합합니다.
   - 순서가 맞지 않는 데이터는 수신자의 버퍼에 저장됩니다.
7. 윈도우 기반 흐름 제어와 혼잡 제어
   - 흐름 제어 : 수신자의 처리 능력을 초과하는 데이터 전송을 방지합니다.
   - 혼잡 제어 : 네트워크 혼잡 상태에서 데이터 전송 속도를 조정해 오류를 줄입니다.
     - 혼잡 윈도우(Congestion Window) 크기를 동적으로 조절합니다.

### TCP Congestion Control (혼잡 제어)

- 네트워크 혼잡을 관리하고 데이터 전송 속도를 동적으로 조정하여 네트워크의 효율성과 안정성을 유지하는 매커니즘
- 혼잡 : 네트워크 트래픽이 라우터나 링크 용량을 초과해 패킷 손실과 지연이 발생하는 상황

#### 혼잡 제어의 주요 단계

1. Slow Start
   - 초기 단계에서 네트워크 용량을 확인하기 위해 전송 속도르 점진적으로 증가시킵니다.
   - 혼잡 윈도우 크기를 1 세그먼트에서 시작해 ACK를 받을 때마다 2배로 증가시킵니다.
   - 혼잡이 발생하면 임계값을 설정하고 Congestion Avoidance 단계로 전환합니다.
2. Congestion Avoidance (혼잡 회피)
   - 혼잡을 예방하기 위해 혼잡 윈도우를 선형적으로 증가시킵니다.
   - 네트워크 상태를 지속적으로 모니터링하며 혼잡을 방지합니다.
3. Fast Recovery
   - 패킷 손실이 발생해도 네트워크가 완전히 혼잡한 상황은 아닐 수 있으므로 전송 속도를 급격히 줄이지 않습니다.
   - 혼잡 윈도우를 임계값으로 줄이고 선형적으로 증가시켜 네트워크 상태를 빠르게 복구합니다.

### TCP Flow Control (흐름 제어)

- 송신자와 수신자 간 데이터 전송 속도를 조정하여 수신자가 자신의 처리 능력을 초과하지 않도록하는 메커니즘입니다.
- 데이터 손실을 방지하고 효율적인 데이터 전송을 보장합니다.

#### 흐름 제어가 필요한 이유

- 송신자는 수신자의 데이터 처리 능력을 알 수 있습니다.
- 송신자가 너무 많은 데이터를 빠르게 보내면 수신자의 버퍼가 초과하여 데이터 손실이 발생할 수 있습니다.
- TCP 흐름 제어는 수신자의 상태에 따라 전송 속도를 동적으로 조절하여 네트워크의 안정성을 유지합니다.

#### TCP 흐름 제어 주요 메커니즘

- 슬라이딩 윈도우 프로토콜
- 송상지는 수신자의 수신 윈도우 크기를 기반으로 데이터를 전송합니다.
- 수신자 -> 송신자로 윈도우 크기를 알려줍니다.
- TCP 헤더의 윈도우 필드를 통해 현재 남아있는 수신 버퍼 크기를 광고합니다.

### 그럼 UDP는 왜 쓰나?

- User Datagram Protocol
- TCP와 달리 연결 지향적이지 않은 비신뢰성 데이터 전송 프로토콜
- 데이터 전송에 대한 보장 없이 단순히 데이터를 빠르게 보내는 데 초점이 맞춰져 있다.
- UDP는 TCP의 연결 설정(3-way handshake), 흐름 제어, 혼잡 제어, 오류 제어 등 복잡한 메커니즘을 생략하기 때문에 오버헤드가 적고 전송 속도가 빠르다.
  - 비디오 스트리밍, 온라인 게임
- 데이터의 지연(Latency)을 최소화합니다. TCP는 데이터를 재전송하거나 순서를 보장하는 과정에서 지연이 발생할 수 있지만 UDP는 이런 과정이 없이 데이터를 바로 전송하기 때문에 **실시간 통신**에 적합합니다.
  - 화상 회의
- UPD는 브로드캐스트(한 네트워크의 모든 장치로 데이터 전송)와 멀티캐스트(특정 그룹으로 데이터 전송)을 지원합니다.
- UDP는 데이터를 단순히 보내는 역할만 수행합니다. 수신 여부를 확인하거나 순서를 조정하지 않으므로 간단한 애플리케이션에서 사용하기 쉽습니다.

#### 단점

1. 패킷 손실, 중복, 순서 변경이 발생해도 복구하지 않습니다.
2. 송신자는 수신자의 처리 능력을 고려하지 않고 데이터를 전송합니다.
3. 데이터가 손상돼도 이를 감지하거나 수정하지 않습니다.

### UDP로는 신뢰성 있는 통신을 할 수 없나?

- 신뢰성을 보장하지 않는 프로토콜입니다.
- UDP를 기반으로 추가적인 로직을 구현하면 신뢰성 있는 통신을 구현할 수 있습니다.
  - 애플리케이션 계층에서 신뢰성을 보장하는 메커니즘을 개발합니다.
- 신뢰성을 추가하면 TCP와 비슷한 수준의 오버헤드가 발생할 수 있습니다.
- 애플리케이션의 요구사항에 따라 UDP의 장점을 최대한 활용하면서 필요한 만큼의 신뢰성만 추가하는 것이 중요합니다.

### 종단 간 신뢰성 보장 어떻게 할 수 있나?

- 종단 간 신뢰성 보장(End-to-End Reliability) : 통신 네트워크에서 송신자와 수신자 사이의 데이터 전송이 신뢰성 있게 이루어지도록 보장하는 과정
- UDP 같은 비신뢰성 프로토콜을 사용하는 경우에도 애플리케이션 계층에서 추가적인 메커니즘을 구현해 종단 간 신뢰성을 보장할 수 있습니다.
- TCP에서 쓰는 메커니즘을 사용하기
- UDP 기반 -> 애플리케이션에 추가적인 메커니즘 구현
  - ACK와 타임아웃 메커니즘 : 데이터를 수신한 후 응답 / 응답이 없으면 재전송 시도
  - 패킷 시퀀스 번호 추가 : 패킷 순서 확인 및 중복된 패킷 제거
  - 에러 수정 코드 : 패킷의 오류를 수정하거나 손실된 데이터 복구

### HTTP란 무엇인가?

- HTTP (HyperText Transfer Protocol) : 웹에서 클라이언트와 서버 간에 데이터를 전송하기 위한 프로토콜
- 웹 페이지와 같은 자원을 요청하고 응답하는 방식으로 동작한다.
- 웹 브라우저와 웹 서버 간에 상호작용을 정의하는 규칙을 설정 -> 웹상에서 데이터를 효율적으로 주고받을 수 있도록 돕습니다.

#### 특징

1. 클라이언트-서버 모델
   - `클라이언트` : 웹 브라우저 또는 HTTP 요청을 보내는 애플리케이션
   - `서버` : 요청에 대해 적절한 응답을 보내는 웹 서버
2. 무상태 프로토콜(Stateless Protocol)
   - 한 번의 요청과 응답 사이에 서버가 클라이언트의 상태를 기억하지 않습니다.
   - 클라이언트는 매 요청마다 서버에게 별도의 정보를 제공해야 합니다.
3. 요청과 응답
   - HTTP는 클라이언트가 요청을 보내고 서버는 이에 대한 응답을 보내는 방식으로 작동합니다.
4. 텍스트 기반
   - HTTP 메시지는 사람이 읽을 수 있는 텍스트 형식으로 작성되어 쉽게 디버깅하고 이해할 수 있습니다.

#### 기본 구조

- 요청과 응답은 헤더와 본문으로 구성됩니다.

#### 요청 메서드

- GET, POST, PUT, DELETE, PATCH

#### 상태 코드

- **2xx (성공)**: 요청이 성공적으로 처리되었음을 나타냅니다.
  - 200 OK: 요청이 성공적으로 처리됨.
  - 201 Created: 요청에 의해 새 자원이 생성됨.
- **3xx (리다이렉션)**: 요청한 자원이 다른 위치에 있음을 나타냅니다.
  - 301 Moved Permanently: 요청한 자원이 영구적으로 이동됨.
  - 302 Found: 요청한 자원이 일시적으로 다른 위치에 있음.
- **4xx (클라이언트 오류)**: 클라이언트의 요청에 문제가 있음을 나타냅니다.
  - 400 Bad Request: 잘못된 요청.
  - 404 Not Found: 요청한 자원을 찾을 수 없음.
  - 403 Forbidden: 요청이 금지됨.
- **5xx (서버 오류)**: 서버에서 문제가 발생했음을 나타냅니다.
  - 500 Internal Server Error: 서버 내부 오류.
  - 502 Bad Gateway: 게이트웨이 또는 프록시 서버에서 오류 발생.

### HTTP 버전별 차이점

1. HTTP/1.1 : 가장 널리 사용되는 HTTP 버전, 요청을 처리할 때 연결 유지 기능을 도입해 성능을 개선했습니다.
2. HTTP/2 : 다중 요청을 동시에 처리할 수 있는 멀티플렉싱과 헤더 압출을 통해 성능을 크게 향상시킨 버전입니다.
3. HTTP/3 : 더 빠르고 안전한 웹 통신을 지원합니다. HTTP/2에서 발생할 수 있는 헤더 지연 문제를 해결하고, UDP 기반으로 보다 빠른 데이터 전송을 제공합니다.

### HOL Blocking이 무엇인가?

- HOL Blocking (Head-of-Line Blocking) : 네트워크나 컴퓨터 시스템에서 데이터 전송을 효율적으로 처리하는데 발생하는 성능 저하 문제
- HOL : 큐의 가장 앞에 있는 패킷
- Blocking : HOL에 있는 패킷이 지연되면 그 이후에 오는 다른 패킷들도 처리하지 않고 대기하게 되는 현상

#### 원인

- 네트워크 스위치나 라우터에서 발생 : 데이터 패킷이 여러 개의 큐를 지나가야 하는 상황에서, 큐의 첫 번째 패킷이 손실되거나 지연되면 그 뒤에 있는 다른 패킷도 함께 지연되거나 손실될 수 있다. 이런 경우 다른 패킷들이 큐의 Head-of-Line에 영향을 받는다.
- TCP 프로토콜에서의 HOL Blocking : TCP는 데이터의 순서 보장과 신뢰성을 중요시하는데 데이터 패킷의 순서가 틀리면 뒤의 패킷을 처리할 수 없게되어 전체적인 데이터 흐름이 지연될 수 있고 이런 상황을 TCP에서의 HOL Blocking이라고 한다.
- 멀티홉 경로에서 발생하는 문제 : 데이터가 여러 라우터나 스위치를 거쳐서 목적지에 도달할 때, 첫 번째 홉에서 발생하는 문제가 전체 경로에 영향을 미칠 수 있다.

### HTTPS는 무엇인가?

- HTTPS (HyperText Transfer Protocol Secure)
- HTTP의 보안 버전
- 웹에서 데이터를 주고받을 때 사용되는 프로토콜
- HTTPS는 암호화된 통신을 통해 보안성을 강화한 프로토콜입니다.

#### 주요 특징

- **암호화(Encryption)**
  - **SSL/TLS(보안 소켓 계층/전송 계층 보안)** 프로토콜을 사용해 데이터 전송 시 암호화합니다.
- 데이터 무결성(Data Integrity)
  - 전송 중에 데이터가 손상되거나 변경되지 않도록 합니다.
  - 데이터 조작을 방지하고 신뢰할 수 있는 데이터가 전송되고 있다는 것을 보장합니다.
- 인증(Authentication)
  - 서버 인증을 통해 서버의 신뢰성을 확인합니다. 클라이언트는 서버가 실제로 자신이 주장하는 서버인지 확인할 수 있습니다.
  - 서버는 디지털 인증서를 사용하여 본임임을 증명하며 인증서는 인증 기관에서 발급됩니다.

#### HTTPS 필요성

- 보안 요구 사항 증가
- SEO(검색 엔진 최적화) : 구글을 비롯한 주요 검색 엔진은 HTTPS를 사용한 웹사이트에 대해 우선순위를 두고 검색 순위를 높여주는 경향이 있습니다.
- 브라우저의 보안 경고

### TLS handshaking / CA인증

- HTTPS에서 사용되는 중요한 보안 메커니즘

#### TLS 핸드셰이크

- 클라이언트와 서버 간에 보안 연결을 설정하는 과정
- 암호화된 데이터 통신을 위한 키 교환, 연결을 안전하게 설정
  - 클라이언트 Hello
  - 서버 Hello
  - 서버 인증 및 공개 키 전송 : 서버는 디지털 인증서를 클라이언트에게 보냅니다.
  - 클라이언트 키 교환 : 서버의 공개 키를 이용해 세션 키를 암호화하고 서버로 전송 -> 데이터 암호화를 위한 대칭 키 -> 이후 데이터 통신에 사용됨
  - 서버 키 교환 확인 : 서버는 클라이언트가 보낸 세션 키를 복호화하여 자신이 사용할 세션 키를 확인하고 서버가 설정한 Finished 메시지를 클라이언트로 보냄
  - 클라이언트 Finished : 클라이언트는 서버가 보낸 메시지가 올바른지 확인한 후, 암호환된 Finished 메시지를 서버로 전송합니다.
  - 암호화된 데이터 전송 시작

#### CA 인증 (Certificate Authority Authentication)

- TLS 핸드셰이크에서 사용되는 중요한 요소
- 웹 캐시 (프록시 서버)
  스위치 vs 라우터
  OSI 7계층은 왜 필요한가?
  DASH, CDN
  비대칭 키와 대칭키를 사용하여 기밀성, 무결성, 인증을 만족하는 통신 과정

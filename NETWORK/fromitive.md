
#### CSMA

Carrier Sense Multiple Access - CD 방식이 있음
네트워크에 연결된 여러 사용자가 통신할 수 있는 방식

Carrier Sense : 네트워크에 연결된 단말기가 회선 사용중인지 확인

Multiple Access : 회선을 사용하지 않는다면 접근(Access)를 시도 - 이 때 여러 컴퓨터가 접근할 수 있어서 Multiple Access라고 하는것임

이때 csma 방식 중 하나가 CD(**C**ollision **D**etection)임

Collision Detection은 충돌을 감지하여 랜덤한 시간을 대기한 뒤 재전송을 하여 여러 컴퓨터가 Multiple Access하도록 하는 방식
Collision Avoidance 방식도 있는데 무선 통신같은 경우 CD가 어렵기 때문에 충돌을 회피하는 방식으로 네트워크 통신을 함

```
1. 프레임을 전송하고자 하는 Station은 매체가 idle인 상태가 될 때까지 기다린다.  
  
2. 만약 idle 상태가 된다면 원거리의 다른 Station이 매체를 이미 사용하고 있을 수도 있기 때문에 IFS(Interframe space)라고 부르는 시간동안 대기한다.  
  
3. IFS동안 대기한 뒤에도 idle 상태라면 Contention Window[[1]](https://namu.wiki/w/CSMA/CA#fn-1)에서 랜덤한 Slot time을 갖고 대기한다.  
  
4. Slot time만큼 대기한 뒤에도 idle 상태라면 전송한 뒤 수신자로부터 ACK 메세지가 오길 기다린다. 이 때, 기다리면서 타이머를 돌리는데 타이머가 끝날 때 까지 ACK 메세지가 자신에게 오지 않으면 다시 뒤로 돌아가서 재전송을 시도한다.  
  
5. ACK 메시지가 도착하면 전송이 성공적으로 이루어졌다고 생각하고 종료한다.
```

IPv4 부족 문제와 해결방안

10.0.0.0
10

172.31
172.32
192.168



TCP 혼잡제어, 흐름제어
#### UDP 신뢰 통신

비연결성이라 신뢰성을 보장하지 못하지만 UDP위에 TCP와 같은 프로토콜기능을 구현하면 할 수는! 있음

#### TCP의 종단간 신뢰성 보장
1. Ack를 이용해 패킷을 잘받았다고 응답
2. 패킷이 중간에 유실되었다면 재전송
3. Sequence Number를 이용하여 패킷 순서 확인
	* Number가 연속적으로 이어지지 않았다면 재전송
4. Checksum 기능을 이용하여 패킷이 오류 및 유실되지 않았는지 확인
	* 전달받은 데이터의 checksum값을 계산한 뒤에 전달받은 checksum값과 비교
#### TLS handShaking 과정

1. clientHello
	* 사용 가능한 TLS 버전 정보와 암호화 정보
	* clientRandom 보냄
2. serverHello
	* 사용 가능한 암호화 방식 중 하나 선택
	* serverRandom, 인증서 보냄 
3. 인증서 검증
	* 클라이언트 인증서 검증
 4. 클라이언트 키교환
	* 클라이언트 serverRandom + clientRandom + premaster secret 값을 합친 키 값을 서버 공개키로 암호화하여 서버에 전달 
5. 서버 키 교환
	* 서버는 서버의 개인키로 대칭키를 복호화 하여 대칭키 획득
6. 키 교환 성공 검증
	* 서버와 클라이언트가 키를 제대로 받았는지 Finished라는 값을 대칭키로 암호화 하여 전달하여 복호화가 됐는지 확인
	* Finished값은 아래의 값을 전송함
``` c

verify_data
         PRF(master_secret, finished_label, Hash(handshake_messages))
            [0..verify_data_length-1];

   The master_secret is hashed with the ClientHello.random and
   ServerHello.random to produce unique data encryption keys and MAC
   secrets for each connection.

   finished_label
	 For Finished messages sent by the client
	 the string "client finished".
	 For Finished messages sent by the server,
	 the string "server finished".
```
### 스위치와 라우터의 차이

스위치는 로컬 통신을 하는 것이고, 라우터는 IP 주소를 이용한 경로제어를 한다. 스위치는 실제로 IP 통신을 하는 것 같지만 같은 네트워크 안의 방화벽 필터링이 먹히지 않아 각 서버마다 OS 방화벽을 사용해야한다. 라우터는 내부 네트워크 주소를 외부 네트워크 주소로 변환하여 패킷을 전송할 수 있게 도와준다.

### 웹 캐시 (프록시 서버)

웹 캐시란 **자주 사용하는 웹 데이터를 저장**해놓고 필요할 때 빠르게 불러오는 기술로 서버 부하를 줄이면서 웹 페이지 로딩 속도를 높일 수 있다.

캐시의 동작 방식

* 웹페이지 첫 방문 시 페이지 정보를 저장한다. 이때 캐시서버 혹은 브라우저에 정보가 저장된다.
* 웹페이지 재 방문시 저장했던 페이지를 빠르게 불러온다.

웹 캐시의 방식

1. 브라우저 캐시
	*  사용자 브라우저에 캐시가 저장되는 방식
	* 주로 정적 리소스를 저장함
	* 브라우저는 요청하기 전 캐시에 해당 데이터가 있는지 확인 만일 존재한다면 요청하지 않고 캐시 메모리에서 가져옴
	* `Cache-Control` 헤더 값으로 캐시 기간을 설정할 수 있음
2. 프록시 캐시
	* 브라우저와 서버 사이에 있는 프록시의 캐시를 활용
	* 사용자가 공통적으로 요청하는 데이터를 캐싱
3. CDN 캐시
	 * CDN을 활용하여 지리적으로 위치가 가까운 네트워크에 캐시 데이터를 저장
 4. 서버 캐시
	 * 자주 요청이 오는 동적 웹 페이지의 결과 캐시서버에 저장 

### OSI 7계층은 왜 필요한가?

책임을 분리하기 위해서

### DASH, CDN

#### DASH
비디오 콘텐츠를 HTTP를 통해 동적으로 적응형으로 스트리밍하는 기술. **인터넷에서 동영상을 끊기지 않고 보게 해주는 기술** 유튜브에서 다양한 화질을 제공하는 것도 dash 덕분이라고 할 수 있음 
dash를 사용하면 동영상 끊김 없이 **동적**으로 화질을 조절해줌으로써 끊임없이 재생할 수 있게 도와준다.
그럼 어떻게 dash는 다양한 화질을 제공할 수 있을까?
대시는 다음과 같은 방법으로 작동함
1. 동영상을 조각(chunk)로 나눈다. 각 조각들은 몇 초짜리 동영상임 
2. 같은 동영상을 여러 화질로 준비한다 (해당 정보는 비디어플레이가 미리 `mpd`(manifest))파일을 요청한다. 이는 화질에 대한 전체 정보를 담고 있음
3. 플레이어가 실시간으로 인터넷 속도를 확인하며 속도가 빠르면 고화질, 낮으면 저화질을 받는다.
4. 조각 하나를 재생하는 동안 다음 조각을 다운로드해서 기다리지 않는다.(버퍼링?)
#### CDN(Content-Delivery-Network)

웹 서비스의 성능을 향상시킬 수 있도록 지리적 위치가 먼 해외 서비스가 국내 회선을 쓴 서버를 별도로 두어 html, css, javascript, 이미지와 같은 정적 이미지 들을 별도의 Web 서버에서 전달하는 Network를 의미한다.
정적 컨텐츠와 동적 컨텐츠 둘 다 CDN 대상이 될 수 있다.

### 비대칭 키와 대칭키를 사용하여 기밀성 무결성, 인증을 만족하는 통신 과정(전자서명)

1. 데이터 변조를 검사하기 위해 데이터를 해시화 한 후 이를 **서버의 개인키로 암호화**한다.
2. 전송 시 암호화된 해시값 및 데이터를 **클라이언트의 공개키로 암호화** 하여 전송한다. 이를 통해 클라이언트의 개인키로만 복호화 할 수 있기 때문에 기밀성이 보장된다.
3. 클라이언트는 **클라이언트의 개인키로 데이터와 암호화 된 해시값을 복호화한다.** 
4. **복호화 한 데이터를 해시화** 하고 **서버의 공개키로 해시값을 복호화** 한다. 이때 서버의 공개키로 복호화를 했기 때문에 해당 서버가 보낸 해시값임을 **인증**할 수 있고, 데이터 해시값과 복호화 한 해시값을 비교함으로써 데이터가 변조되지 않았음(무결성)을 보장할 수 있다.
## 데이터베이스에서 인덱스를 사용하는 이유와 장단점
* 인덱스를 사용하면 대량의 데이터를 조회할 때 빠르게 찾을 수 있다. 1억건의 데이터가 있더라도 데이터 조회는 수십 ms단위로 줄일 수 있다.
* 다만, 수정, 삭제, 조회 시 인덱스 테이블을 다시 생성해야하기 때문에 조회 삭제 로직이 느리다.
## innoDB 인덱스 구조
* B+-tree구조로 밸런스가 맞춰져있음. 
* [innodb index 구조](https://dev.mysql.com/doc/refman/8.4/en/innodb-physical-structure.html)
## InnoDB 버퍼 풀, REDO로그, UNDO로그
트랜잭션이란?
* DB에 데이터를 반영하기 위한 작업의 한 단위를 뜻함.
* 트렌젝션은 원자성, 일관성, 격리성, 영속성을 만족해야함
* 원자성 : 트렌젝션 범위 작업이 하나 실패하면 다 실패 해야함
* 일관성 : 트렌젝션이 시작하고 끝날때의 데이터가 일관적으로 유지해야함
* 격리성 : 트렌젝션은 다른 트렌젝션간 영향을 받으면 안됨
* 영속성 : 트렌젝션의 데이터는 영속화 되어서 시스템이 장애나도 복구가 되야 함
# 트랜잭션 격리 수준
read-uncommited (커밋하지 않은 변경된 데이터 읽힘 : 격리가 안됨)
read-commmited (non-repeatable-read: 다른 트렌젝션에서 커밋 완료시 변경된 데이터를 읽음)
repeatable-read (phantom-read: 다른 트렌젝션에서 커밋 완료되어 생성한 데이터 결과가 나타남)
serialize (모든 커밋 직렬화시켜서 병렬 작업을 1개의 작업으로 합처버림)

## MySQL의 Repeatable Read에서의 Phantom Read

next key gab lock과 mvcc(multi-version-concurrency-control)을 이용해 phantom-read를 방지

mvcc : 하나의 트렌젝션을 시작할 때 스냅샷을 생성하여 달라진 버전을 읽지 않도록 구성
next key gab lock : 새로 추가할 데이터의 공간을 선점해서 다른 데이터가 들어가지 못하도록 락을 거는것

## 데이터베이스 정규화란?
일관적이고 효과적인 데이터의 관계를 정리하는 것

## Join이란?
테이블과 테이블을 연관시켜 데이터를 조회하는 방식

## RDBMS vs NoSQL
NoSQL은 데이터 구조가 자유로움, RDBMS는 테이블 구조임

## CAP 정리(브루어 정리)
일관성, 네트워크 단절, 가용성은 한번에 만족시킬 수 없으니까 적절히 시스템을 구성해라 이말이야

## 파티셔닝과 샤딩
논리적으로 나눈것 물리적으로 나눈것
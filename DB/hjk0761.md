[데이터베이스]
- 데이터베이스에서 인덱스를 사용하는 이유와 장단점
    - 장점: 정렬된 상태 유지로 조회 성능 향상
    - 단점: 인덱스를 저장하기 위한 메모리 필요, 조회 이외의 작업(추가, 삭제, 수정 등)시 기존 인덱스 구조를 새로 만들어야 함
- InnoDB 인덱스 구조
    - B-Tree(balanced-tree): 루트 노드(인덱스 키:자식 노드 주소), 브랜치 노드(인덱스 키:자식 노드 주소), 리프 노드(인덱스 키:PK 혹은 주소)
    - 디스크 I/O 를 최대한 줄임
    - 클러스터링 인덱스: PK 기준으로 클러스터링
    - Secondary Index: 클러스터링 인덱스(PK 인덱스) 를 제외한 모든 인덱스
    - 스캔
        - 인덱스 레인지 스캔: 검색해야 할 인덱스의 범위가 결정된 경우, 리프 노드에서 시작점을 찾고 거기부터 쭉 읽어나감
        - 인덱스 풀 스캔: 쿼리의 조건절에서 사용된 칼럼이 인덱스의 첫 번째가 아닌 경우, 인덱스 처음부터 쭉 읽어나감
        - 루스 인덱스 스캔: 중간에 필요하지 않은 인덱스 키 값은 넘어가며 읽어나감
        - 인덱스 스킵 스캔: 필요하지 않은 인덱스 칼럼을 건너뛰고 읽어나감
- InnoDB 버퍼 풀, REDO로그, UNDO로그
    - InnoDB 버퍼 풀: 캐싱을 위한 메모리 공간, MySQL 서버 종료 시 유실
    - REDO 로그: 변경 내용을 로그로 먼저 기록하여 비정상적인 서버 종료 시 이를 통해 복구
    - UNDO 로그: 변경되지 이전의 데이터를 보관, 트랜잭션 및 격리 수준 보장을 위해 사용
- 트랜잭션이란?
    - 작업완전성, 데이터정합성을 보장하기 위해 논리적인 작업 단위를 온전히 반영하거나, 온전히 복구하도록 하는 기능, MySQL 기준 InnoDB 스토리지 엔진만 트랜잭션 사용
        - 원자성(Atomicity): 트랜잭션은 온전히 반영되거나, 전혀 반영되지 않아야 함
        - 일관성(Consistency): 트랜잭션의 처리 결과는 일관성 있어야 함
        - 독립성(Isolation): 하나의 트랜잭션의 연산에 다른 트랜잭션이 끼어들 수 없음
        - 지속성(Durability): 트랜잭션이 성공적으로 완료된 경우 결과는 영구적으로 반영되어야 함
    - 작업 성공 시 Commit 으로 반영 후 결과를 로그에 저장, 실패 시 Rollback 으로 트랜잭션 이전 상태로 복구
- 트랜잭션 격리 수준: 여러 트랜잭션 간의 작업 내용을 어더ㄸㅎ게 공유하고 차단할 지 결정하는 레벨
    - Read Uncommited: 각 트랜잭션의 변경 사항이 Commit, Rollback 여부와 상관없이 다른 트랜잭션에서 읽을 수 있음
        - Dirty Read(커밋되지 않은 데이터를 읽을 수 있는 현상), Non-Repeatable Read, Phantom Read 발생
    - Read Commited: Commit 이 완료된 데이터만 다른 트랜잭션에서 조회 가능(오라클 Default)
        - Non-Repeatable Read(한 트랜잭션에서 같은 쿼리를 쏠 때 결과가 다를 수 있는 현상), Phantom Read 발생
    - Repeatable Read: 변경 전 데이터를 언두 로그로 복사해 한 트랜잭션 안에선 같은 결과가 나오도록 개선(MySQL:InnoDB 스토리지 엔진 Default)
        - 사실 InnoDB 스토리지 엔진에서 Read Commited 도 이 방법을 사용하지만 이는 주기적으로 삭제됨. Repeatable Read 에서는 현재 트랜잭션 이후의 언두 로그 데이터를 삭제할 수 없도록 제한해 트랜잭션 내부에선 같은 결과를 볼 수 있도록 함
        - Phantom Read(다른 트랜잭션의 수행에 의해 레코드가 보이거나 안보이는 현상) 발생
    - Serializable: 읽기 작업에서도 공유 락을 획득해야 함. 
- MySQL의 Repeatable Read에서의 Phantom Read
      - InnoDB 스토리지 엔진에서는 갭 락, 넥스트 키 락을 통해 SELECT FOR UPDATE, SELECT LOCK IN SHARE MODE 를 제외하면 Phantom Read 는 발생하지 않음: 이들 쿼리는 레코드에 쓰기 잠금을 거는데 언두 레코드에는 잠금을 걸 수 없으므로 현재 레코드의 값을 가져오게 됨.
- 데이터베이스 정규화란?
    - 정의: 데이터 중복을 줄이고 무결성을 향상시키기 위한 과정, 일반적으로 테이블을 작고 잘 조직된 테이블로 나누는 과정을 의미
        - 제1정규화: 삽입, 갱신, 삭제 이상을 방지하기 위함: 각 요소는 한 개의 값을 가지고, 중복된 테이블을 분리한다.
        - 제2정규화: 기본키 중 특정 컬럼에만 종속된 컬럼이 없는 상태(완전 함수 종속: 후보키에 속하지 않은 속성은 기본키 전체로만 결정되어야 함)
        - 제3정규화: 테이블 내의 키가 아닌 모든 컬럼이 테이블의 모든 키에 이행적 종속이 되지 않는 상태(이행 종속: x->y, y->z 일 때 x->z 성립)
        - BCNF: 모든 결정자가 후보키가 된 상태
- Join이란?
    - 복수의 테이블을 연결하는 것
    - Inner join, Outer join, left join, right join
- RDBMS vs NoSQL
    - RDBMS: 관계형 데이터를 기반으로 모든 데이터를 2차원 테이블 형태로 표현하는 데이터베이스 시스템, 외래키를 통한 Join 가능
        - 장점: 명확한 데이터 구조를 보장, 데이터가 중복되지 않음
        - 단점: 시스템이 커질 경우 복잡한 쿼리가 생성 가능, Scale-up 만을 지원, 스키마 변경이 어려움.
    - NoSQL: 스키마와 특정한 데이터 구조 없이, Document, key-value 등 다양한 형태로 저장. Scale-out 을 용이하게 하기 위해 테이블 간 관계를 정의하지 않음. 
        - 장점: 스키마가 없어 유연하며 자유로운 데이터 구조를 가질 수 있음. 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있음.
        - 단점: 데이터 중복이 발생 가능, 중복된 데이터 모든 컬렉션에서 수정 수행. 명확한 데이터 구조를 보장하지 않음, 데이터 구조 결정이 어려움
- CAP 정리(브루어 정리)
    - 다음 세 조건을 모두 만족하는 분산 시스템은 존재하지 않는다.
        - consistency(일관성): 모든 노드가 같은 순간에 같은 데이터를 볼 수 있다.
        - availability(가용성): 모든 요청이 성공 또는 실패 등의 결과를 반환활 수 있다.
        - partition tolerance(분할 허용성): 메시지 전달이 실패하거나 시스템 일부가 망가져도 시스템이 계속 동작할 수 있다.
- 파티셔닝과 샤딩
    - 파티셔닝: 매우 큰 테이블을 여러개의 테이블로 분리, 물리적으로 분리된 테이블이지만 사용자는 하나의 테이블에 접근하는 것으로 느껴짐
    - 샤딩: 동일한 스키마를 가진 여러 DB 서버에 데이터를 분산 저장